Hello from /home/carlos/.vscode/extensions/jaredly.reason-vscode-1.4.1/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","refmt":"","lispRefmt":"","format_width":"80","per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","languageId":"reason","version":1,"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}}}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
[1/1] [34mBuilding[39m [2msrc/ParserC-ParserLibrary.cmj[22m

  We've found a bug for you!
  /home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re 175:45
  
  173 │ 
  174 │ let rec s = arg => run(
  175 │     parserOr(parseString("a"),parserAnd({fn:s,nombre:"parserS"},parse
        String("a"))),
  176 │     arg)
  177 │     
  
  This has type:
    'a => 'b
  But somewhere wanted:
    parserFn(string)
  
>>> stderr

Affected files: file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Deps 
Got source directories ./src - ./src/node_modules - ./src/node_modules/.lsp
Source directories: /home/carlos/Documentos/pruebas_reason/parser-library/src - /home/carlos/Documentos/pruebas_reason/parser-library/src/node_modules - /home/carlos/Documentos/pruebas_reason/parser-library/src/node_modules/.lsp
Source files found: /home/carlos/Documentos/pruebas_reason/parser-library/src/Fraccionario.re : /home/carlos/Documentos/pruebas_reason/parser-library/src/Pruebas.re : /home/carlos/Documentos/pruebas_reason/parser-library/src/Demo.re : /home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
adding namespace ParserLibrary : ParserLibrary : /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
-- All local modules found: 5
ParserLibrary
impl /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Fraccionario-ParserLibrary
impl /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/Fraccionario-ParserLibrary.cmt
Pruebas-ParserLibrary
impl /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/Pruebas-ParserLibrary.cmt
Demo-ParserLibrary
impl /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/Demo-ParserLibrary.cmt
ParserC-ParserLibrary
impl /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/ParserC-ParserLibrary.cmt
############ Namespaced as ParserLibrary at /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Dependency dirs /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Making lastDefinitions with type error for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 175, characters 44-45[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 174, "character": 44}, "end": {"line": 174, "character": 45}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":57},"end":{"line":177,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":177,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":174,"character":44},"end":{"line":174,"character":45}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":57},"end":{"line":177,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":57},"end":{"line":177,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 5, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":8},"end":{"line":175,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 7, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 8, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 4}, "end": {"line": 174, "character": 12}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 9, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 4}, "end": {"line": 174, "character": 12}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 10, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 13}, "end": {"line": 174, "character": 24}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 11, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 19}, "end": {"line": 173, "character": 22}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":57},"end":{"line":177,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 12, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":172,"character":0},"end":{"line":173,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 13, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":171,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 14, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":171,"character":0},"end":{"line":171,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 15, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":2},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":3},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 16, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 177, characters 44-45[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 44}, "end": {"line": 176, "character": 45}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":176,"character":44},"end":{"line":176,"character":45}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 17, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":5},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nle\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 18, "jsonrpc": "2.0", "result": [{"label": "lor", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical or.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:281"}, {"label": "lsr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n lsr m` shifts `n` to the right by `m` bits. This is a logical shift: zeroes are inserted regardless of the sign of `n`. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:296"}, {"label": "lsl", "kind": 12, "detail": "(int, int) => int", "documentation": "`n lsl m` shifts `n` to the left by `m` bits. The result is unspecified if `m < 0` or `m >= bitsize`, where `bitsize` is `32` on a 32-bit platform and `64` on a 64-bit platform.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:290"}, {"label": "log10", "kind": 12, "detail": "float => float", "documentation": "Base 10 logarithm.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:355"}, {"label": "lxor", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical exclusive or.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:284"}, {"label": "land", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical and.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:278"}, {"label": "log1p", "kind": 12, "detail": "float => float", "documentation": "`log1p x` computes `log(1.0 +. x)` \\(natural logarithm\\), giving numerically-accurate results even if `x` is close to `0.0`.\n\nSince: 3.12.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:364"}, {"label": "lnot", "kind": 12, "detail": "int => int", "documentation": "Bitwise logical negation.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:287"}, {"label": "ldexp", "kind": 12, "detail": "(float, int) => float", "documentation": "`ldexp x n` returns `x *. 2 ** n`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:531"}, {"label": "log", "kind": 12, "detail": "float => float", "documentation": "Natural logarithm.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:352"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":7},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet \n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 19, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 0}, "end": {"line": 175, "character": 3}}, "message": "Error: 1896: let is a reserved keyword, it cannot be used as an identifier. Try `let_` or `_let` instead", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":8},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0548362731934ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 20, "jsonrpc": "2.0", "result": [{"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":9},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 21, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":6},"end":{"line":173,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 22, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":0},"end":{"line":175,"character":3}},"message":"Error: 1896: let is a reserved keyword, it cannot be used as an identifier. Try `let_` or `_let` instead","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 23, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":10},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 \n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 24, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":11},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 =\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 0}, "end": {"line": 175, "character": 3}}, "message": "Error: 1946: let is a reserved keyword, it cannot be used as an identifier. Try `let_` or `_let` instead", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Nothing completable found :/
Sending response {"id": 25, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":18},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parser\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":0},"end":{"line":175,"character":3}},"message":"Error: 1946: let is a reserved keyword, it cannot be used as an identifier. Try `let_` or `_let` instead","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 26, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 27, "jsonrpc": "2.0", "result": [{"label": "parserMap", "kind": 12, "detail": "(\n  string => string,\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:148"}, {"label": "parserOr", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111"}, {"label": "parserReturn", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:164"}, {"label": "parserAnd", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:128"}, {"label": "parser", "kind": 22, "detail": "type parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9"}, {"label": "parserFn", "kind": 22, "detail": "type parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:7"}]}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 28, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":15},"end":{"line":173,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 29, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":30,"method":"completionItem/resolve","params":{"label":"parser","detail":"type parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.00500679016113ms
Sending response {"id": 30, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 174, characters 9-15[0m[0m:
[1;31mError[0m: Unbound value parser
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 15}}, "message": "Error: Unbound value parser\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":19},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parserS\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":15}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 31, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 32, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 174, characters 9-16[0m[0m:
[1;31mError[0m: Unbound value parserS
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 16}}, "message": "Error: Unbound value parserS\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":16},"end":{"line":173,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 33, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":16}},"message":"Error: Unbound value parserS\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 34, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":20},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parserSt\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 35, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":21},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parserStr\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 36, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":18},"end":{"line":173,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 37, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 174, characters 9-18[0m[0m:
[1;31mError[0m: Unbound value parserStr
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 18}}, "message": "Error: Unbound value parserStr\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":18}},"message":"Error: Unbound value parserStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 38, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":18},"end":{"line":173,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":18}},"message":"Error: Unbound value parserStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 39, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":17}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 40, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":14},"end":{"line":173,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":18}},"message":"Error: Unbound value parserStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 41, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":22},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseStr\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":42,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":17}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 42, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":43,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 43, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":44,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":17},"end":{"line":173,"character":17}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":18}},"message":"Error: Unbound value parserStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 44, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":45,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 45, "jsonrpc": "2.0", "result": [{"label": "parseString", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77"}]}
Read message 
{"jsonrpc":"2.0","id":46,"method":"completionItem/resolve","params":{"label":"parseString","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00691413879395ms
Sending response {"id": 46, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 174, characters 9-17[0m[0m:
[1;31mError[0m: Unbound value parseStr
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 17}}, "message": "Error: Unbound value parseStr\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":47,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":17}},"message":"Error: Unbound value parseStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 47, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":48,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":17},"end":{"line":173,"character":17}},"context":{"diagnostics":[{"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":17}},"message":"Error: Unbound value parseStr\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 48, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":23},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":49,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 49, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":50,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":20},"end":{"line":173,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 50, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 177, characters 44-45[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 44}, "end": {"line": 176, "character": 45}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":24},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString()\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":51,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":176,"character":44},"end":{"line":176,"character":45}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 51, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":52,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":21}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00596046447754ms
Signature help lident parseString
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 52, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "string => parser(string)", "documentation": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "string"}]}]}}
Read message 
{"jsonrpc":"2.0","id":53,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 53, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":54,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":21},"end":{"line":173,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 54, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":25},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"\")\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":55,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":22}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 55, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":56,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 56, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":57,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":22},"end":{"line":173,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 57, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":55}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":26},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\n\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":58,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":23}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00500679016113ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 58, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":59,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 59, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 177, characters 44-45[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 44}, "end": {"line": 176, "character": 45}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":60,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":23},"end":{"line":173,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 60, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":61,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":25},"end":{"line":173,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 61, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":60}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":27},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":62,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 62, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 44-45[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 44}, "end": {"line": 175, "character": 45}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":63,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":0},"end":{"line":174,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 63, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":64,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":178,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":44},"end":{"line":175,"character":45}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 64, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":65,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":7},"end":{"line":174,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 65, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":66,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":9},"end":{"line":174,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 66, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":28},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserOr(parseString(\"a\"),parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":67,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 67, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":68,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 68, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":69,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":10},"end":{"line":174,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 69, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 44-45[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 44}, "end": {"line": 175, "character": 45}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":70,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":178,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":44},"end":{"line":175,"character":45}},"message":"Error: Unbound value s","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 70, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":71,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":10},"end":{"line":174,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 71, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":72,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":11}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 72, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":73,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":12},"end":{"line":174,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 73, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":74,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":13}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Got a loc for pos
Sending response {"id": 74, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 174, "character": 13}, "end": {"line": 174, "character": 16}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":75,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":174,"character":13},"end":{"line":174,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 75, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":76,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Got a loc for pos
Sending response {"id": 76, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 175, "character": 13}, "end": {"line": 175, "character": 24}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 37}, "end": {"line": 169, "character": 48}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 11}, "end": {"line": 169, "character": 22}}, "kind": 2}, {"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 20}}, "kind": 2}, {"range": {"start": {"line": 76, "character": 4}, "end": {"line": 76, "character": 15}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":77,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":14},"end":{"line":175,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 77, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":78,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":13},"end":{"line":175,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 78, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":79,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":14},"end":{"line":175,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 79, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":80,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":26},"end":{"line":175,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 80, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":81,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":27}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Got a loc for pos
Sending response {"id": 81, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":82,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 82, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":83,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":30},"end":{"line":175,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 83, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":84,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":4},"end":{"line":175,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 84, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":29},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},parseString(\"a\"))),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":85,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 85, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":86,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":4},"end":{"line":175,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 86, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 4}, "end": {"line": 176, "character": 7}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":87,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":178,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":176,"character":4},"end":{"line":176,"character":7}},"message":"Error: Syntax error","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 87, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":88,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":17},"end":{"line":175,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 88, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":89,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 89, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":90,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 90, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":91,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":17},"end":{"line":175,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 91, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":92,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":20},"end":{"line":175,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 92, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":93,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":37}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 93, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":94,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":48},"end":{"line":175,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 94, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":95,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":35},"end":{"line":175,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 95, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":96,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":38},"end":{"line":175,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 96, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":97,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":38},"end":{"line":175,"character":51}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 97, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":98,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":38},"end":{"line":175,"character":52}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 98, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":99,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":38},"end":{"line":175,"character":53}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 99, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":38},"end":{"line":175,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 100, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":30},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s)),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":101,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 101, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "'b => 'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":102,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 102, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":103,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":39},"end":{"line":175,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 103, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 4}, "end": {"line": 176, "character": 7}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":31},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1)),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":104,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 104, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":102}}
Read message 
{"jsonrpc":"2.0","id":105,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 105, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":106,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":40},"end":{"line":175,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 106, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":103}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":104}}
Read message 
{"jsonrpc":"2.0","id":107,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":41},"end":{"line":175,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 107, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 176, "character": 4}, "end": {"line": 176, "character": 7}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":108,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":40}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 108, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":109,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":40},"end":{"line":175,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 109, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":110,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":41},"end":{"line":175,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 110, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":32},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":111,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 111, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":112,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":178,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: Unbound value s","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 112, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":113,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":41},"end":{"line":175,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 113, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":114,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":176,"character":8},"end":{"line":176,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 114, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":115,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 115, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":116,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 116, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":117,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 117, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":118,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":22}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 118, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 20}, "end": {"line": 174, "character": 23}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":119,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":171,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 119, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":120,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":96,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 120, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":121,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":79,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Trying for declared Value 1171 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 121, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 79, "character": 12}, "end": {"line": 79, "character": 22}}, "contents": {"kind": "markdown", "value": "```\nint\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":122,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":47,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1150 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 122, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 47, "character": 8}, "end": {"line": 47, "character": 21}}, "contents": {"kind": "markdown", "value": "```\n(\n  Hashtbl.t(string, parseResult('a)),\n  string,\n  parseResult('a)\n) => bool\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":123,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":178,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: Unbound value s","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 123, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":32},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":124,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0679492950439ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 124, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":125,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 125, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":126,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":176,"character":8},"end":{"line":176,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 126, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":126}}
Read message 
{"jsonrpc":"2.0","id":127,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":57},"end":{"line":178,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 127, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":128,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":169,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 128, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 169, "character": 23}, "end": {"line": 169, "character": 31}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":129,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 129, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":130,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 130, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":131,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":176,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 131, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":132,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 132, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":133,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 133, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":134,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 134, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":135,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":40}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 135, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":136,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":41}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 136, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":137,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":40}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 137, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":138,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":40}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 138, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":139,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":40},"end":{"line":175,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 139, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":140,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 140, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":141,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":176,"character":8},"end":{"line":176,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 141, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":142,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 142, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":143,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0739097595215ms
Sending response {"id": 143, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":144,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 144, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":145,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 145, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":146,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0710487365723ms
Sending response {"id": 146, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":147,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 147, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":33},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\n    \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":148,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 148, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":34},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\n\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":149,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 149, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":35},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\na\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":150,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 150, "jsonrpc": "2.0", "result": [{"label": "arg", "kind": 12, "detail": "'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "atan2", "kind": 12, "detail": "(float, float) => float", "documentation": "`atan2 y x` returns the arc tangent of `y /. x`. The signs of `x` and `y` are used to determine the quadrant of the result. Result is in radians and is between `-pi` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:391"}, {"label": "asr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302"}, {"label": "abs", "kind": 12, "detail": "int => int", "documentation": "Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265"}, {"label": "asin", "kind": 12, "detail": "float => float", "documentation": "Arc sine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:383"}, {"label": "acos", "kind": 12, "detail": "float => float", "documentation": "Arc cosine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `0.0` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:379"}, {"label": "atan", "kind": 12, "detail": "float => float", "documentation": "Arc tangent. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:387"}, {"label": "abs_float", "kind": 12, "detail": "float => float", "documentation": "`abs_float f` returns the absolute value of `f`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:424"}, {"label": "at_exit", "kind": 12, "detail": "unit => unit => unit", "documentation": "Register the given function to be called at program termination time. The functions registered with `at_exit` will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in 'last in, first out' order: the function most recently added with `at_exit` is called first.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1202"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":38},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":39},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":151,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 151, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "'b => 'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":152,"method":"completionItem/resolve","params":{"label":"s","detail":"'b => 'a","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00905990600586ms
Sending response {"id": 152, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":153,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 153, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":154,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":5},"end":{"line":177,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0641345977783ms
Sending response {"id": 154, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 174, "character": 0}, "end": {"line": 176, "character": 8}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":155,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":174,"character":0},"end":{"line":176,"character":8}},"message":"Error: Syntax error","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 155, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":156,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":5},"end":{"line":177,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 156, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":41},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s =\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":157,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Nothing completable found :/
Sending response {"id": 157, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":42},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":158,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 158, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 180, characters 15-16[0m[0m:
[1;31mError[0m: This expression has type parserFn(string)
       but an expression was expected of type
         (string, continuation('a)) => unit
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 179, "character": 15}, "end": {"line": 179, "character": 16}}, "message": "Error: This expression has type parserFn(string)\n       but an expression was expected of type\n         (string, continuation('a)) => unit", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":159,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":179,"character":15},"end":{"line":179,"character":16}},"message":"Error: This expression has type parserFn(string)\n       but an expression was expected of type\n         (string, continuation('a)) => unit","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 159, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":43},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = a\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":160,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 160, "jsonrpc": "2.0", "result": [{"label": "arg", "kind": 12, "detail": "'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "atan2", "kind": 12, "detail": "(float, float) => float", "documentation": "`atan2 y x` returns the arc tangent of `y /. x`. The signs of `x` and `y` are used to determine the quadrant of the result. Result is in radians and is between `-pi` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:391"}, {"label": "asr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302"}, {"label": "abs", "kind": 12, "detail": "int => int", "documentation": "Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265"}, {"label": "asin", "kind": 12, "detail": "float => float", "documentation": "Arc sine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:383"}, {"label": "acos", "kind": 12, "detail": "float => float", "documentation": "Arc cosine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `0.0` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:379"}, {"label": "atan", "kind": 12, "detail": "float => float", "documentation": "Arc tangent. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:387"}, {"label": "abs_float", "kind": 12, "detail": "float => float", "documentation": "`abs_float f` returns the absolute value of `f`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:424"}, {"label": "at_exit", "kind": 12, "detail": "unit => unit => unit", "documentation": "Register the given function to be called at program termination time. The functions registered with `at_exit` will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in 'last in, first out' order: the function most recently added with `at_exit` is called first.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1202"}]}
Read message 
{"jsonrpc":"2.0","id":161,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0607967376709ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 161, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 178, characters 8-9[0m[0m:
[1;31mError[0m: Unbound value a
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 177, "character": 8}, "end": {"line": 177, "character": 9}}, "message": "Error: Unbound value a", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":162,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":9},"end":{"line":177,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0760555267334ms
Sending response {"id": 162, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":163,"method":"completionItem/resolve","params":{"label":"abs","detail":"int => int","documentation":"Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.539064407349ms
Sending response {"id": 163, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":163}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":44},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = ar\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":164,"method":"completionItem/resolve","params":{"label":"arg","detail":"'a","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00810623168945ms
Sending response {"id": 164, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":164}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":46},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":165,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":177,"character":8},"end":{"line":177,"character":9}},"message":"Error: Unbound value a","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.102043151855ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 165, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":166,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0648498535156ms
Sending response {"id": 166, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":48},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg 0>\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":167,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.06103515625ms
Nothing completable found :/
Sending response {"id": 167, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":49},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg 0> \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":168,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 168, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 174, "character": 0}, "end": {"line": 177, "character": 11}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":52},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":169,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":174,"character":0},"end":{"line":177,"character":11}},"message":"Error: Syntax error","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 169, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":170,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
Sending response {"id": 170, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 178, characters 8-11[0m[0m:
[1;31mError[0m: Unbound value arg
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 177, "character": 8}, "end": {"line": 177, "character": 11}}, "message": "Error: Unbound value arg", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":171,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":177,"character":8},"end":{"line":177,"character":11}},"message":"Error: Unbound value arg","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0689029693604ms
Sending response {"id": 171, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":53},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg =\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":172,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Nothing completable found :/
Sending response {"id": 172, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":54},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg =>\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":55},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => \n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":173,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0600814819336ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 173, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":174,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":179,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0848770141602ms
Sending response {"id": 174, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":56},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => r\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":175,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 175, "jsonrpc": "2.0", "result": [{"label": "run", "kind": 12, "detail": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:19"}, {"label": "read_float", "kind": 12, "detail": "unit => float", "documentation": "Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:797"}, {"label": "ref", "kind": 12, "detail": "'a => ref('a)", "documentation": "Return a fresh reference containing the given value.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1069"}, {"label": "raise_notrace", "kind": 12, "detail": "exn => 'a", "documentation": "A faster version `raise` which does not record the backtrace.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:31"}, {"label": "read_line", "kind": 12, "detail": "unit => string", "documentation": "Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:787"}, {"label": "really_input", "kind": 12, "detail": "(in_channel, bytes, int, int) => unit", "documentation": "`really_input ic buf pos len` reads `len` characters from channel `ic`, storing them in byte sequence `buf`, starting at character number `pos`. Raise `End_of_file` if the end of file is reached before `len` characters have been read. Raise `Invalid_argument \"really_input\"` if `pos` and `len` do not designate a valid range of `buf`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:975"}, {"label": "really_input_string", "kind": 12, "detail": "(in_channel, int) => string", "documentation": "`really_input_string ic len` reads `len` characters from channel `ic` and returns them in a new string. Raise `End_of_file` if the end of file is reached before `len` characters have been read.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:983"}, {"label": "raise", "kind": 12, "detail": "exn => 'a", "documentation": "Raise the given exception value\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:28"}, {"label": "read_int", "kind": 12, "detail": "unit => int", "documentation": "Flush standard output, then read one line from standard input and convert it to an integer. Raise `Failure \"int_of_string\"` if the line read is not a valid representation of an integer.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:792"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":57},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => ru\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":58},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":176,"method":"completionItem/resolve","params":{"label":"run","detail":"(\n  parser('a),\n  string,\n  continuation('a)\n) => unit","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:19","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00905990600586ms
Sending response {"id": 176, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":177,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 177, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":178,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":18},"end":{"line":177,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0879764556885ms
Sending response {"id": 178, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":59},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run()\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":179,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":19}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0121593475342ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 179, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":180,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0588893890381ms
Sending response {"id": 180, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":181,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":19},"end":{"line":177,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 181, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":60},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    \n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":182,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":4}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0159740447998ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 182, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":183,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0691413879395ms
Sending response {"id": 183, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":184,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":171,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 184, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":185,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":169,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 185, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 169, "character": 11}, "end": {"line": 169, "character": 22}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":61},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    p\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":186,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 186, "jsonrpc": "2.0", "result": [{"label": "parserMap", "kind": 12, "detail": "(\n  string => string,\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:148"}, {"label": "parseString", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77"}, {"label": "parserOr", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111"}, {"label": "parserReturn", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:164"}, {"label": "parseChar", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95"}, {"label": "parserAnd", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:128"}, {"label": "parser", "kind": 22, "detail": "type parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9"}, {"label": "parseResult", "kind": 22, "detail": "type parseResult('a) = \n  | Exito('a, string)\n  | Fallo(string, string)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "parserFn", "kind": 22, "detail": "type parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:7"}, {"label": "prerr_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:758"}, {"label": "pos_out", "kind": 12, "detail": "out_channel => int", "documentation": "Return the current writing position for the given channel. Does not work on channels opened with the `Open_append` flag \\(returns unspecified results\\).\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:896"}, {"label": "pred", "kind": 12, "detail": "int => int", "documentation": "`pred x` is `x - 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:236"}, {"label": "pos_in", "kind": 12, "detail": "in_channel => int", "documentation": "Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013"}, {"label": "print_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:725"}, {"label": "print_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:732"}, {"label": "prerr_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:768"}, {"label": "print_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:735"}, {"label": "print_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:747"}, {"label": "print_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard output.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:728"}, {"label": "prerr_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard error.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:761"}, {"label": "prerr_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755"}, {"label": "print_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:739"}, {"label": "prerr_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard error, and flush standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:780"}, {"label": "prerr_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:772"}, {"label": "print_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:722"}, {"label": "prerr_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:765"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":62},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    pa\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":187,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":6}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 187, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":188,"method":"completionItem/resolve","params":{"label":"parseChar","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0591278076172ms
Sending response {"id": 188, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":187}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":63},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    par\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":66},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parser\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":189,"method":"completionItem/resolve","params":{"label":"parser","detail":"type parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.00905990600586ms
Sending response {"id": 189, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":190,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":10}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 190, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":191,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0600814819336ms
Sending response {"id": 191, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":192,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":10},"end":{"line":178,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 192, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":67},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserO\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":193,"method":"completionItem/resolve","params":{"label":"parserOr","detail":"(\n  parser(string),\n  parser(string)\n) => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00786781311035ms
Sending response {"id": 193, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":194,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":11}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 194, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":195,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0689029693604ms
Sending response {"id": 195, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":196,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":11},"end":{"line":178,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 196, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":68},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":197,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":12}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 197, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":198,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0600814819336ms
Sending response {"id": 198, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":199,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":12},"end":{"line":178,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 199, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":69},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr()\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":200,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":13}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 200, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":201,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0979900360107ms
Sending response {"id": 201, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":202,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":13},"end":{"line":178,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 202, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":70},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s)\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":203,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 203, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "'b => 'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":204,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":14}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 204, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":205,"method":"completionItem/resolve","params":{"label":"s","detail":"'b => 'a","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.065803527832ms
Sending response {"id": 205, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":204}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":71},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1)\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":206,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":15}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 206, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":207,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
Sending response {"id": 207, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":208,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":15},"end":{"line":178,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 208, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":72},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1,)\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":209,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Nothing completable found :/
Sending response {"id": 209, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":210,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":16}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 210, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":210}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":73},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, )\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":211,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":17}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 211, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":212,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
Sending response {"id": 212, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":213,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 213, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":74},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, s)\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":214,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 214, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "'b => 'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":215,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":18}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.06103515625ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 215, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":216,"method":"completionItem/resolve","params":{"label":"s","detail":"'b => 'a","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.06103515625ms
Sending response {"id": 216, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":217,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 217, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":218,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":18},"end":{"line":178,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 218, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":219,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":17}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0960826873779ms
Sending response {"id": 219, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":220,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":17}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00905990600586ms
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 220, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":221,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 221, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":222,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":18}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 222, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":223,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":18},"end":{"line":178,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 223, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":75},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, )\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":224,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":17}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Found a type signature
Sending response {"id": 224, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "No docs"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":225,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0700950622559ms
Sending response {"id": 225, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":226,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 226, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":76},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":227,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":18}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 227, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":228,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0591278076172ms
Sending response {"id": 228, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":229,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":18},"end":{"line":178,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 229, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":77},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {f})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":230,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0250339508057ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 230, "jsonrpc": "2.0", "result": [{"label": "fn", "kind": 5, "detail": "fn: 'a parserFn\n\ntype parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "format_of_string", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => format6('a, 'b, 'c, 'd, 'e, 'f)", "documentation": "`format_of_string s` returns a format string read from the string literal `s`. Note: `format_of_string` can not convert a string argument that is not a literal. If you need this functionality, use the more general format_from_string function.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1169"}, {"label": "failwith", "kind": 12, "detail": "string => 'a", "documentation": "Raise exception `Failure` with the given string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:39"}, {"label": "float", "kind": 12, "detail": "int => float", "documentation": "Same as float_of_int.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:538"}, {"label": "fst", "kind": 12, "detail": "(('a, 'b)) => 'a", "documentation": "Return the first component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:684"}, {"label": "float_of_int", "kind": 12, "detail": "int => float", "documentation": "Convert an integer to floating-point.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:541"}, {"label": "flush", "kind": 12, "detail": "out_channel => unit", "documentation": "Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:839"}, {"label": "flush_all", "kind": 12, "detail": "unit => unit", "documentation": "Flush all open output channels; ignore errors.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:845"}, {"label": "frexp", "kind": 12, "detail": "float => (float, int)", "documentation": "`frexp f` returns the pair of the significant and the exponent of `f`. When `f` is zero, the significant `x` and the exponent `n` of `f` are equal to zero. When `f` is non-zero, they are defined by `f = x *. 2 ** n` and `0.5 <= x < 1.0`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:524"}, {"label": "float_of_string", "kind": 12, "detail": "string => float", "documentation": "Convert the given string to a float. Raise `Failure \"float_of_string\"` if the given string is not a valid representation of a float.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:677"}, {"label": "floor", "kind": 12, "detail": "float => float", "documentation": "Round below to an integer value. `floor f` returns the greatest integer value less than or equal to `f`. The result is returned as a float.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:418"}, {"label": "format4", "kind": 22, "detail": "type format4('a, 'b, 'c, 'd) = format6(\n  'a,\n  'b,\n  'c,\n  'c,\n  'c,\n  'd\n)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1162"}, {"label": "format", "kind": 22, "detail": "type format('a, 'b, 'c) = format4('a, 'b, 'c, 'c)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1164"}, {"label": "format6", "kind": 22, "detail": "type format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) = CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1159"}, {"label": "fpclass", "kind": 22, "detail": "type fpclass = \n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\n", "documentation": "The five classes of floating-point numbers, as determined by the classify_float function.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:592"}]}
Read message 
{"jsonrpc":"2.0","id":231,"method":"completionItem/resolve","params":{"label":"failwith","detail":"string => 'a","documentation":"Raise exception `Failure` with the given string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:39","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0131130218506ms
Sending response {"id": 231, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":232,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 232, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":233,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":19},"end":{"line":178,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0669956207275ms
Sending response {"id": 233, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":78},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":234,"method":"completionItem/resolve","params":{"label":"fn","detail":"fn: 'a parserFn\n\ntype parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1","insertTextFormat":1,"kind":5}}
[server] Got a method completionItem/resolve
[server] processing took 0.0951290130615ms
Sending response {"id": 234, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":235,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 235, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":236,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":20},"end":{"line":178,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0629425048828ms
Sending response {"id": 236, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":79},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":237,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0598430633545ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 237, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 22}}, "message": "Error: Syntax error: '}' expected", "severity": 1}, {"range": {"start": {"line": 178, "character": 17}, "end": {"line": 178, "character": 18}}, "message": "Error: This '{' might be unmatched", "severity": 1}, {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":238,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 238, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":239,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":181,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":22}},"message":"Error: Syntax error: '}' expected","severity":1},{"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":18}},"message":"Error: This '{' might be unmatched","severity":1},{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 239, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":240,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":181,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":22}},"message":"Error: Syntax error: '}' expected","severity":1},{"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":18}},"message":"Error: This '{' might be unmatched","severity":1},{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 240, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":241,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":181,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":22}},"message":"Error: Syntax error: '}' expected","severity":1},{"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":18}},"message":"Error: This '{' might be unmatched","severity":1},{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 241, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":80},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":242,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0851154327393ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 242, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "'b => 'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":81},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":243,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0598430633545ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 243, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":244,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 244, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":245,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":23},"end":{"line":178,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.149965286255ms
Sending response {"id": 245, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":246,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":181,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 246, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":247,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":23},"end":{"line":178,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 247, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":82},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":248,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Nothing completable found :/
Sending response {"id": 248, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":249,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 249, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":250,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":24},"end":{"line":178,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.06103515625ms
Sending response {"id": 250, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":83},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,n})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":251,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 251, "jsonrpc": "2.0", "result": [{"label": "nombre", "kind": 5, "detail": "nombre: string\n\ntype parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "not", "kind": 12, "detail": "bool => bool", "documentation": "The boolean negation.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:129"}, {"label": "nan", "kind": 12, "detail": "float", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:556"}, {"label": "neg_infinity", "kind": 12, "detail": "float", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:554"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":85},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nom})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":252,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 252, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":86},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nomb})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":253,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 253, "jsonrpc": "2.0", "result": [{"label": "nombre", "kind": 5, "detail": "nombre: string\n\ntype parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":88},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":254,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0629425048828ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 254, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":255,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":30},"end":{"line":178,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0631809234619ms
Sending response {"id": 255, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":89},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":256,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Nothing completable found :/
Sending response {"id": 256, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":90},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"\"})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":257,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 257, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":258,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":32},"end":{"line":178,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 258, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":92},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"pa\"})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":259,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 259, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":96},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parser\"})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":260,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 260, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":261,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":38},"end":{"line":178,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0600814819336ms
Sending response {"id": 261, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":97},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS\"})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":98},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"})\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":262,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 262, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":263,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":40},"end":{"line":178,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0622272491455ms
Sending response {"id": 263, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":264,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":43},"end":{"line":178,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 264, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":99},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":265,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":44},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0169277191162ms
Nothing completable found :/
Sending response {"id": 265, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":266,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 266, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":267,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":44},"end":{"line":178,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 267, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":100},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),1\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":268,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 268, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":269,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":45},"end":{"line":178,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0729560852051ms
Sending response {"id": 269, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":101},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":102},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    \n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":270,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 270, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":103},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    a\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":271,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":179,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 271, "jsonrpc": "2.0", "result": [{"label": "arg", "kind": 12, "detail": "'a", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "atan2", "kind": 12, "detail": "(float, float) => float", "documentation": "`atan2 y x` returns the arc tangent of `y /. x`. The signs of `x` and `y` are used to determine the quadrant of the result. Result is in radians and is between `-pi` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:391"}, {"label": "asr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302"}, {"label": "abs", "kind": 12, "detail": "int => int", "documentation": "Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265"}, {"label": "asin", "kind": 12, "detail": "float => float", "documentation": "Arc sine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:383"}, {"label": "acos", "kind": 12, "detail": "float => float", "documentation": "Arc cosine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `0.0` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:379"}, {"label": "atan", "kind": 12, "detail": "float => float", "documentation": "Arc tangent. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:387"}, {"label": "abs_float", "kind": 12, "detail": "float => float", "documentation": "`abs_float f` returns the absolute value of `f`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:424"}, {"label": "at_exit", "kind": 12, "detail": "unit => unit => unit", "documentation": "Register the given function to be called at program termination time. The functions registered with `at_exit` will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in 'last in, first out' order: the function most recently added with `at_exit` is called first.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1202"}]}
Read message 
{"jsonrpc":"2.0","id":272,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0431537628174ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 272, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":273,"method":"completionItem/resolve","params":{"label":"abs","detail":"int => int","documentation":"Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.143051147461ms
Sending response {"id": 273, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":274,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":179,"character":5},"end":{"line":179,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 274, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":104},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    ar\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":275,"method":"completionItem/resolve","params":{"label":"arg","detail":"'a","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00786781311035ms
Sending response {"id": 275, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":276,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 276, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":277,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":179,"character":6},"end":{"line":179,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 277, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":105},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":278,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 278, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":279,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":179,"character":7},"end":{"line":179,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0588893890381ms
Sending response {"id": 279, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":106},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":280,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 280, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":281,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 281, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":282,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 282, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":283,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 283, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 177, "character": 4}, "end": {"line": 177, "character": 5}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":284,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":180,"character":1},"end":{"line":180,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 284, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":285,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 285, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":286,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 286, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":287,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 287, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":106},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:s,nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":106}}}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
[1/2] [34mBuilding[39m [2msrc/ParserC.mlast[22m
[2/2] [34mBuilding[39m [2msrc/ParserC.mlast.d[22m
[1/1] [34mBuilding[39m [2msrc/ParserC-ParserLibrary.cmj[22m

  We've found a bug for you!
  /home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re 176:19
  
  174 │ let s1 = parseString("a")
  175 │ let rec s2 = arg => run(
  176 │     parserAnd({fn:s,nombre:"parserS"},s1),
  177 │     arg)
  178 │ and s = arg => run(
  
  This has type:
    'a => 'b
  But somewhere wanted:
    parserFn(string)
  
>>> stderr

Affected files: file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Pruebas.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/Pruebas-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Pruebas.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Pruebas.re", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Fraccionario.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/Fraccionario-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Fraccionario.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Fraccionario.re", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Demo.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/Demo-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Demo.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/Demo.re", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":288,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0591278076172ms
Sending response {"id": 288, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":289,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0162124633789ms
Sending response {"id": 289, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":290,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 290, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":291,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":42}}}
[server] Got a method textDocument/hover
[server] processing took 0.0240802764893ms
Sending response {"id": 291, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":292,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":42}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00977516174316ms
Sending response {"id": 292, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":293,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":42},"end":{"line":175,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 293, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":294,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":176,"character":8},"end":{"line":176,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 294, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":295,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":41}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 295, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":296,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":42},"end":{"line":178,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 296, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":297,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":41}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 297, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":298,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":41},"end":{"line":178,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 298, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":299,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":42},"end":{"line":178,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 299, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":300,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":41}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 300, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":301,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":41},"end":{"line":178,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 301, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":302,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":42},"end":{"line":178,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 302, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":303,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 303, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":304,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Sending response {"id": 304, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":305,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 305, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 177, "character": 4}, "end": {"line": 177, "character": 5}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":306,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 306, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 177, "character": 4}, "end": {"line": 177, "character": 5}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":307,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 307, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":308,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 308, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":309,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 309, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":310,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 310, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":311,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":177,"character":15},"end":{"line":177,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 311, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":312,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 312, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":313,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 313, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":314,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 314, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":315,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 315, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":316,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":182,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 316, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":317,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":182,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 317, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":318,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 318, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":319,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":148,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1203 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 319, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 148, "character": 8}, "end": {"line": 148, "character": 15}}, "contents": {"kind": "markdown", "value": "```\n(\n  string,\n  parseResult(string) => unit\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":320,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":148,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Got a loc for pos
Sending response {"id": 320, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 158, "character": 23}, "end": {"line": 158, "character": 30}}, "kind": 2}, {"range": {"start": {"line": 148, "character": 8}, "end": {"line": 148, "character": 15}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":321,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":148,"character":14},"end":{"line":148,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 321, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":322,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":132,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 322, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":323,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":84,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 323, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":324,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":84,"character":14},"end":{"line":84,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 324, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":325,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":52,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Got a loc for pos
Sending response {"id": 325, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 72, "character": 26}, "end": {"line": 72, "character": 33}}, "kind": 2}, {"range": {"start": {"line": 52, "character": 8}, "end": {"line": 52, "character": 15}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":326,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":52,"character":14},"end":{"line":52,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 326, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":327,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":36,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 327, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":328,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":36,"character":14},"end":{"line":36,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 328, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":329,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":20,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 329, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":330,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":20,"character":14},"end":{"line":20,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 330, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":331,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":4,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 331, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 6, "character": 39}, "end": {"line": 6, "character": 51}}, "kind": 2}, {"range": {"start": {"line": 77, "character": 28}, "end": {"line": 77, "character": 40}}, "kind": 2}, {"range": {"start": {"line": 95, "character": 36}, "end": {"line": 95, "character": 48}}, "kind": 2}, {"range": {"start": {"line": 4, "character": 5}, "end": {"line": 4, "character": 17}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":332,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":4,"character":14},"end":{"line":4,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 332, "jsonrpc": "2.0", "result": [{"title": "Add to interface file", "command": "reason-language-server.add_to_interface_inner", "arguments": ["file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "type continuation('a) = parseResult('a) => unit"]}]}
Read message 
{"jsonrpc":"2.0","id":333,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":19,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 333, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":334,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1023 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 334, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 11}, "end": {"line": 18, "character": 17}}, "contents": {"kind": "markdown", "value": "```\nparser('a)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":335,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 335, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":336,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1023 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 336, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 11}, "end": {"line": 18, "character": 17}}, "contents": {"kind": "markdown", "value": "```\nparser('a)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":337,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 337, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":338,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 338, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":339,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":20,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 339, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 20, "character": 2}, "end": {"line": 20, "character": 8}}, "contents": {"kind": "markdown", "value": "```\nparserFn('a)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":340,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 340, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":341,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 341, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":342,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 342, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":343,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":18,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 343, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":344,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":28,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 344, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":345,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 345, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":346,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 346, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 4}, "end": {"line": 173, "character": 6}}, "contents": {"kind": "markdown", "value": "```\nparser(string)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":347,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 347, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":348,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 348, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":349,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Trying for declared Value 1219 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 349, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 13}, "end": {"line": 174, "character": 16}}, "contents": {"kind": "markdown", "value": "```\n'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":350,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 350, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 20}, "end": {"line": 174, "character": 23}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":351,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 351, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":352,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 352, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":353,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 353, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":354,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 354, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":355,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 355, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":356,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1218 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 356, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "contents": {"kind": "markdown", "value": "```\n'b => 'a\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":357,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":179,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 357, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":358,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0181198120117ms
Sending response {"id": 358, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":359,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 359, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":360,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 360, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":361,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 361, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":362,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 362, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":363,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 363, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":364,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 364, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":365,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Got a loc for pos
Sending response {"id": 365, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 177, "character": 4}, "end": {"line": 177, "character": 5}}, "kind": 2}, {"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":366,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 366, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":367,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":182,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 367, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":368,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 368, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":107},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":369,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":20}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 369, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":370,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0598430633545ms
Sending response {"id": 370, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":371,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":19},"end":{"line":175,"character":20}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 371, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":372,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":19}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Got a loc for pos
Sending response {"id": 372, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 177, "character": 4}, "end": {"line": 177, "character": 5}}, "kind": 2}, {"range": {"start": {"line": 175, "character": 19}, "end": {"line": 175, "character": 20}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":373,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":18}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 373, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 176, characters 18-21[0m[0m:
[1;31mError[0m: This expression has type 'a => 'b
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 21}}, "message": "Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":374,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":21}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 374, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":375,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":21}},"message":"Error: This expression has type 'a => 'b\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 375, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":108},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:P(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 176, characters 18-19[0m[0m:
[1;31mError[0m: This record expression is expected to have type parser(string)
       The constructor P does not belong to type parserFn
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 175, "character": 18}, "end": {"line": 175, "character": 19}}, "message": "Error: This record expression is expected to have type parser(string)\n       The constructor P does not belong to type parserFn", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":376,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 376, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "Pruebas", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printf", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printexc", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Pervasives", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":113},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:s2,nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":377,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":175,"character":18},"end":{"line":175,"character":19}},"message":"Error: This record expression is expected to have type parser(string)\n       The constructor P does not belong to type parserFn","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 377, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":378,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0598430633545ms
Sending response {"id": 378, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":379,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":24},"end":{"line":175,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0641345977783ms
Sending response {"id": 379, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 179, characters 21-23[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 23}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":380,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 380, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":381,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":175,"character":24},"end":{"line":175,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 381, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":382,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":23}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Got a loc for pos
Sending response {"id": 382, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "kind": 2}, {"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 23}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":383,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":23},"end":{"line":179,"character":7}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 383, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":384,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":182,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 384, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":385,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":23}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 385, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "kind": 2}, {"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 23}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":386,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":23},"end":{"line":178,"character":23}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 386, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":387,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 387, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":114},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":388,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":24}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 388, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":389,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0698566436768ms
Sending response {"id": 389, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":390,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":22},"end":{"line":178,"character":24}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":23}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 390, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":391,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":22}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Got a loc for pos
Sending response {"id": 391, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "kind": 2}, {"range": {"start": {"line": 178, "character": 22}, "end": {"line": 178, "character": 24}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":392,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 392, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 179, characters 21-25[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type parserFn(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 25}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":393,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":25}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 393, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":394,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":21}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":25}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 394, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":115},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:P(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":395,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 395, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "Pruebas", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printf", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printexc", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Pervasives", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":116},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Pa(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":396,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 396, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":118},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Pars(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 179, characters 21-25[0m[0m:
[1;31mError[0m: This record expression is expected to have type parser(string)
       The constructor Pars does not belong to type parserFn
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 25}}, "message": "Error: This record expression is expected to have type parser(string)\n       The constructor Pars does not belong to type parserFn", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":397,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0641345977783ms
Sending response {"id": 397, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":398,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":25},"end":{"line":178,"character":25}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":25}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type parserFn(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0660419464111ms
Sending response {"id": 398, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":119},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parse(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":399,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 399, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","id":400,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":178,"character":21},"end":{"line":178,"character":25}},"message":"Error: This record expression is expected to have type parser(string)\n       The constructor Pars does not belong to type parserFn","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 400, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":120},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":401,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 401, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":402,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":27},"end":{"line":178,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 402, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":403,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":178,"character":27},"end":{"line":178,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 403, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":402}}
Read message 
{"jsonrpc":"2.0","id":404,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 404, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":405,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 405, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 4}, "end": {"line": 173, "character": 6}}, "contents": {"kind": "markdown", "value": "```\nparser(string)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":406,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 406, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 173, "character": 4}, "end": {"line": 173, "character": 6}}, "contents": {"kind": "markdown", "value": "```\nparser(string)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":407,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 407, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":408,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 408, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":409,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 409, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":410,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0219345092773ms
Trying for declared Value 1219 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 410, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 13}, "end": {"line": 174, "character": 16}}, "contents": {"kind": "markdown", "value": "```\nstring\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":411,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 411, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 20}, "end": {"line": 174, "character": 23}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":412,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":175,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 412, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 175, "character": 4}, "end": {"line": 175, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":413,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.00977516174316ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 413, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 20}, "end": {"line": 174, "character": 23}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":414,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 414, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":415,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":177,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0221729278564ms
Trying for declared Value 1220 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 415, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 177, "character": 8}, "end": {"line": 177, "character": 11}}, "contents": {"kind": "markdown", "value": "```\nstring\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":416,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Sending response {"id": 416, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 178, "character": 18}, "end": {"line": 178, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nparser('a)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":417,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Sending response {"id": 417, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 27}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":418,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 418, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 178, "character": 21}, "end": {"line": 178, "character": 27}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":120},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\nlet s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":120}}}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
[1/2] [34mBuilding[39m [2msrc/ParserC.mlast[22m
[2/2] [34mBuilding[39m [2msrc/ParserC.mlast.d[22m
[1/1] [34mBuilding[39m [2msrc/ParserC-ParserLibrary.cmj[22m
>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":419,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":174,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 419, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 174, "character": 8}, "end": {"line": 174, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":420,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Got a loc for pos
Sending response {"id": 420, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 173, "character": 9}, "end": {"line": 173, "character": 20}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 37}, "end": {"line": 169, "character": 48}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 11}, "end": {"line": 169, "character": 22}}, "kind": 2}, {"range": {"start": {"line": 76, "character": 4}, "end": {"line": 76, "character": 15}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":421,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":9},"end":{"line":173,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 421, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":422,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":173,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 422, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":423,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":0},"end":{"line":173,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 423, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":424,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":0},"end":{"line":181,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 424, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":121},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":425,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 425, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 183, characters 15-16[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 182, "character": 15}, "end": {"line": 182, "character": 16}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":426,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":3},"end":{"line":181,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 426, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":427,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":182,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":182,"character":15},"end":{"line":182,"character":16}},"message":"Error: Unbound value s","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 427, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":428,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":173,"character":3},"end":{"line":181,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 428, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":429,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":182,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 429, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 182, "character": 0}, "end": {"line": 182, "character": 3}}, "kind": 2}, {"range": {"start": {"line": 25, "character": 4}, "end": {"line": 25, "character": 7}}, "kind": 2}, {"range": {"start": {"line": 56, "character": 12}, "end": {"line": 56, "character": 15}}, "kind": 2}, {"range": {"start": {"line": 117, "character": 16}, "end": {"line": 117, "character": 19}}, "kind": 2}, {"range": {"start": {"line": 116, "character": 16}, "end": {"line": 116, "character": 19}}, "kind": 2}, {"range": {"start": {"line": 135, "character": 24}, "end": {"line": 135, "character": 27}}, "kind": 2}, {"range": {"start": {"line": 132, "character": 15}, "end": {"line": 132, "character": 18}}, "kind": 2}, {"range": {"start": {"line": 153, "character": 20}, "end": {"line": 153, "character": 23}}, "kind": 2}, {"range": {"start": {"line": 18, "character": 4}, "end": {"line": 18, "character": 7}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":430,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":182,"character":57},"end":{"line":182,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 430, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":122},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":431,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 431, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":123},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":432,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.068187713623ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 432, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 15-16[0m[0m:
[1;31mError[0m: Unbound value s
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 15}, "end": {"line": 184, "character": 16}}, "message": "Error: Unbound value s", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":433,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":15},"end":{"line":184,"character":16}},"message":"Error: Unbound value s","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 433, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":124},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n l\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":434,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":2},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 434, "jsonrpc": "2.0", "result": [{"label": "lor", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical or.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:281"}, {"label": "lsr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n lsr m` shifts `n` to the right by `m` bits. This is a logical shift: zeroes are inserted regardless of the sign of `n`. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:296"}, {"label": "lsl", "kind": 12, "detail": "(int, int) => int", "documentation": "`n lsl m` shifts `n` to the left by `m` bits. The result is unspecified if `m < 0` or `m >= bitsize`, where `bitsize` is `32` on a 32-bit platform and `64` on a 64-bit platform.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:290"}, {"label": "log10", "kind": 12, "detail": "float => float", "documentation": "Base 10 logarithm.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:355"}, {"label": "lxor", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical exclusive or.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:284"}, {"label": "land", "kind": 12, "detail": "(int, int) => int", "documentation": "Bitwise logical and.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:278"}, {"label": "log1p", "kind": 12, "detail": "float => float", "documentation": "`log1p x` computes `log(1.0 +. x)` \\(natural logarithm\\), giving numerically-accurate results even if `x` is close to `0.0`.\n\nSince: 3.12.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:364"}, {"label": "lnot", "kind": 12, "detail": "int => int", "documentation": "Bitwise logical negation.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:287"}, {"label": "ldexp", "kind": 12, "detail": "(float, int) => float", "documentation": "`ldexp x n` returns `x *. 2 ** n`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:531"}, {"label": "log", "kind": 12, "detail": "float => float", "documentation": "Natural logarithm.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:352"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":126},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lwe\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":435,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 435, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":436,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":4},"end":{"line":183,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0989437103271ms
Sending response {"id": 436, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 1-4[0m[0m:
[1;31mError[0m: Unbound value lwe
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 1}, "end": {"line": 183, "character": 4}}, "message": "Error: Unbound value lwe", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":437,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":4}},"message":"Error: Unbound value lwe","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 437, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":128},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n l\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":438,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 438, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 1-2[0m[0m:
[1;31mError[0m: Unbound value l
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 1}, "end": {"line": 183, "character": 2}}, "message": "Error: Unbound value l", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":439,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":2},"end":{"line":183,"character":2}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":4}},"message":"Error: Unbound value lwe","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 439, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":440,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":2}},"message":"Error: Unbound value l","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 440, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":441,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":2},"end":{"line":183,"character":2}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":2}},"message":"Error: Unbound value l","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 441, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":129},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lw\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":442,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 442, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":443,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 443, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":444,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":3},"end":{"line":183,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0910758972168ms
Sending response {"id": 444, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":130},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lwt\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":445,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 445, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":446,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 446, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":447,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":4},"end":{"line":183,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 447, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":131},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lwt \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":448,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 448, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":132},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lwt r\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":449,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 449, "jsonrpc": "2.0", "result": [{"label": "run", "kind": 12, "detail": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:19"}, {"label": "read_float", "kind": 12, "detail": "unit => float", "documentation": "Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:797"}, {"label": "ref", "kind": 12, "detail": "'a => ref('a)", "documentation": "Return a fresh reference containing the given value.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1069"}, {"label": "raise_notrace", "kind": 12, "detail": "exn => 'a", "documentation": "A faster version `raise` which does not record the backtrace.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:31"}, {"label": "read_line", "kind": 12, "detail": "unit => string", "documentation": "Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:787"}, {"label": "really_input", "kind": 12, "detail": "(in_channel, bytes, int, int) => unit", "documentation": "`really_input ic buf pos len` reads `len` characters from channel `ic`, storing them in byte sequence `buf`, starting at character number `pos`. Raise `End_of_file` if the end of file is reached before `len` characters have been read. Raise `Invalid_argument \"really_input\"` if `pos` and `len` do not designate a valid range of `buf`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:975"}, {"label": "really_input_string", "kind": 12, "detail": "(in_channel, int) => string", "documentation": "`really_input_string ic len` reads `len` characters from channel `ic` and returns them in a new string. Raise `End_of_file` if the end of file is reached before `len` characters have been read.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:983"}, {"label": "raise", "kind": 12, "detail": "exn => 'a", "documentation": "Raise the given exception value\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:28"}, {"label": "read_int", "kind": 12, "detail": "unit => int", "documentation": "Flush standard output, then read one line from standard input and convert it to an integer. Raise `Failure \"int_of_string\"` if the line read is not a valid representation of an integer.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:792"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":133},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n lwt re\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":450,"method":"completionItem/resolve","params":{"label":"read_float","detail":"unit => float","documentation":"Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:797","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00905990600586ms
Sending response {"id": 450, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":451,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 451, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":452,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":7},"end":{"line":183,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 452, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":453,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":6}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 453, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 1-4[0m[0m:
[1;31mError[0m: Unbound value lwt
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 1}, "end": {"line": 183, "character": 4}}, "message": "Error: Unbound value lwt", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":454,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":4}},"message":"Error: Unbound value lwt","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 454, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":455,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":4}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 455, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":456,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":2},"end":{"line":183,"character":2}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":4}},"message":"Error: Unbound value lwt","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 456, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":135},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let re\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":457,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":3},"end":{"line":183,"character":3}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":1},"end":{"line":183,"character":4}},"message":"Error: Unbound value lwt","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 457, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":458,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0929832458496ms
Sending response {"id": 458, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":459,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":7}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 459, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 0}, "end": {"line": 184, "character": 3}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":460,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":0},"end":{"line":184,"character":3}},"message":"Error: Syntax error","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 5.49793243408ms
Sending response {"id": 460, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":461,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":7},"end":{"line":183,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 461, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":136},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":462,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 462, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":138},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":463,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 463, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "(string, continuation(string)) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178"}, {"label": "s2", "kind": 12, "detail": "(string, continuation(string)) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:175"}, {"label": "s1", "kind": 12, "detail": "parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":464,"method":"completionItem/resolve","params":{"label":"s","detail":"(string, continuation(string)) => unit","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0200271606445ms
Sending response {"id": 464, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":465,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.195026397705ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 465, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":466,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":10},"end":{"line":183,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0631809234619ms
Sending response {"id": 466, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 0}, "end": {"line": 184, "character": 3}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":139},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":467,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 467, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 0}, "end": {"line": 184, "character": 3}}, "message": "Error: Syntax error", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":140},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s =\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":468,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0641345977783ms
Nothing completable found :/
Sending response {"id": 468, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":469,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 469, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":470,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":12},"end":{"line":183,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 470, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":141},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":471,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 471, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 0-57[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         (string, continuation('a)) => unit
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 0}, "end": {"line": 184, "character": 57}}, "message": "Error: This expression has type unit but an expression was expected of type\n         (string, continuation('a)) => unit", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":472,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":0},"end":{"line":184,"character":57}},"message":"Error: This expression has type unit but an expression was expected of type\n         (string, continuation('a)) => unit","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 472, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":142},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = p\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":473,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 473, "jsonrpc": "2.0", "result": [{"label": "parserMap", "kind": 12, "detail": "(\n  string => string,\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:148"}, {"label": "parseString", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77"}, {"label": "parserOr", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111"}, {"label": "parserReturn", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:164"}, {"label": "parseChar", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95"}, {"label": "parserAnd", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:128"}, {"label": "parser", "kind": 22, "detail": "type parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9"}, {"label": "parseResult", "kind": 22, "detail": "type parseResult('a) = \n  | Exito('a, string)\n  | Fallo(string, string)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "parserFn", "kind": 22, "detail": "type parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:7"}, {"label": "prerr_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:758"}, {"label": "pos_out", "kind": 12, "detail": "out_channel => int", "documentation": "Return the current writing position for the given channel. Does not work on channels opened with the `Open_append` flag \\(returns unspecified results\\).\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:896"}, {"label": "pred", "kind": 12, "detail": "int => int", "documentation": "`pred x` is `x - 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:236"}, {"label": "pos_in", "kind": 12, "detail": "in_channel => int", "documentation": "Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013"}, {"label": "print_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:725"}, {"label": "print_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:732"}, {"label": "prerr_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:768"}, {"label": "print_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:735"}, {"label": "print_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:747"}, {"label": "print_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard output.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:728"}, {"label": "prerr_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard error.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:761"}, {"label": "prerr_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755"}, {"label": "print_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:739"}, {"label": "prerr_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard error, and flush standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:780"}, {"label": "prerr_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:772"}, {"label": "print_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:722"}, {"label": "prerr_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:765"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":143},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = pa\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":144},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = par\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":474,"method":"completionItem/resolve","params":{"label":"parseChar","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0932216644287ms
Sending response {"id": 474, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 184, characters 13-16[0m[0m:
[1;31mError[0m: Unbound value par
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 13}, "end": {"line": 183, "character": 16}}, "message": "Error: Unbound value par", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":147},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = parser\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":475,"method":"completionItem/resolve","params":{"label":"parser","detail":"type parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.0100135803223ms
Sending response {"id": 475, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":476,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 476, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":477,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":19},"end":{"line":183,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0741481781006ms
Sending response {"id": 477, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":478,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":13},"end":{"line":183,"character":16}},"message":"Error: Unbound value par","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0638961791992ms
Sending response {"id": 478, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":479,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":19},"end":{"line":183,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 479, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 13-19[0m[0m:
[1;31mError[0m: Unbound value parser
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 13}, "end": {"line": 183, "character": 19}}, "message": "Error: Unbound value parser\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":480,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":13},"end":{"line":183,"character":19}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 480, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":481,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":19},"end":{"line":183,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":13},"end":{"line":183,"character":19}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 481, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":148},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = parse\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 184, characters 13-18[0m[0m:
[1;31mError[0m: Unbound value parse
Hint: Did you mean raise?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 13}, "end": {"line": 183, "character": 18}}, "message": "Error: Unbound value parse\nHint: Did you mean raise?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":152},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = p\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":153},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":482,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":13},"end":{"line":183,"character":18}},"message":"Error: Unbound value parse\nHint: Did you mean raise?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 482, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":483,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.128030776978ms
Sending response {"id": 483, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":154},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = a\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":484,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.075101852417ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 484, "jsonrpc": "2.0", "result": [{"label": "arg", "kind": 12, "detail": "string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178"}, {"label": "atan2", "kind": 12, "detail": "(float, float) => float", "documentation": "`atan2 y x` returns the arc tangent of `y /. x`. The signs of `x` and `y` are used to determine the quadrant of the result. Result is in radians and is between `-pi` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:391"}, {"label": "asr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302"}, {"label": "abs", "kind": 12, "detail": "int => int", "documentation": "Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265"}, {"label": "asin", "kind": 12, "detail": "float => float", "documentation": "Arc sine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:383"}, {"label": "acos", "kind": 12, "detail": "float => float", "documentation": "Arc cosine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `0.0` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:379"}, {"label": "atan", "kind": 12, "detail": "float => float", "documentation": "Arc tangent. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:387"}, {"label": "abs_float", "kind": 12, "detail": "float => float", "documentation": "`abs_float f` returns the absolute value of `f`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:424"}, {"label": "at_exit", "kind": 12, "detail": "unit => unit => unit", "documentation": "Register the given function to be called at program termination time. The functions registered with `at_exit` will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in 'last in, first out' order: the function most recently added with `at_exit` is called first.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1202"}]}
Read message 
{"jsonrpc":"2.0","id":485,"method":"completionItem/resolve","params":{"label":"abs","detail":"int => int","documentation":"Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00905990600586ms
Sending response {"id": 485, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":486,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 486, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":487,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":14},"end":{"line":183,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":13},"end":{"line":183,"character":18}},"message":"Error: Unbound value parse\nHint: Did you mean raise?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.144958496094ms
Sending response {"id": 487, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":155},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = ar\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":488,"method":"completionItem/resolve","params":{"label":"arg","detail":"string","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0691413879395ms
Sending response {"id": 488, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":156},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":158},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg =\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":489,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Nothing completable found :/
Sending response {"id": 489, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":159},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg =>\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":160},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => \nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":490,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 490, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 0-57[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         continuation('a) => unit
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 0}, "end": {"line": 184, "character": 57}}, "message": "Error: This expression has type unit but an expression was expected of type\n         continuation('a) => unit", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":491,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":184,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":0},"end":{"line":184,"character":57}},"message":"Error: This expression has type unit but an expression was expected of type\n         continuation('a) => unit","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 491, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":161},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => r\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":492,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 492, "jsonrpc": "2.0", "result": [{"label": "run", "kind": 12, "detail": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:19"}, {"label": "read_float", "kind": 12, "detail": "unit => float", "documentation": "Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:797"}, {"label": "ref", "kind": 12, "detail": "'a => ref('a)", "documentation": "Return a fresh reference containing the given value.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1069"}, {"label": "raise_notrace", "kind": 12, "detail": "exn => 'a", "documentation": "A faster version `raise` which does not record the backtrace.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:31"}, {"label": "read_line", "kind": 12, "detail": "unit => string", "documentation": "Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:787"}, {"label": "really_input", "kind": 12, "detail": "(in_channel, bytes, int, int) => unit", "documentation": "`really_input ic buf pos len` reads `len` characters from channel `ic`, storing them in byte sequence `buf`, starting at character number `pos`. Raise `End_of_file` if the end of file is reached before `len` characters have been read. Raise `Invalid_argument \"really_input\"` if `pos` and `len` do not designate a valid range of `buf`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:975"}, {"label": "really_input_string", "kind": 12, "detail": "(in_channel, int) => string", "documentation": "`really_input_string ic len` reads `len` characters from channel `ic` and returns them in a new string. Raise `End_of_file` if the end of file is reached before `len` characters have been read.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:983"}, {"label": "raise", "kind": 12, "detail": "exn => 'a", "documentation": "Raise the given exception value\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:28"}, {"label": "read_int", "kind": 12, "detail": "unit => int", "documentation": "Flush standard output, then read one line from standard input and convert it to an integer. Raise `Failure \"int_of_string\"` if the line read is not a valid representation of an integer.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:792"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":162},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => ru\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":493,"method":"completionItem/resolve","params":{"label":"run","detail":"(\n  parser('a),\n  string,\n  continuation('a)\n) => unit","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:19","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00882148742676ms
Sending response {"id": 493, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":163},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":494,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 494, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":495,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":23},"end":{"line":183,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.294923782349ms
Sending response {"id": 495, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":164},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run()\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":496,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":24}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00715255737305ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 496, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":497,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0631809234619ms
Sending response {"id": 497, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":498,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":183,"character":24},"end":{"line":183,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 498, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":165},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     \n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":499,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":5}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 499, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":500,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0810623168945ms
Sending response {"id": 500, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 23-33[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser('a)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 23}, "end": {"line": 185, "character": 2}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser('a)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":501,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":23},"end":{"line":185,"character":2}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 501, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":166},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     p\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":502,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 502, "jsonrpc": "2.0", "result": [{"label": "parserMap", "kind": 12, "detail": "(\n  string => string,\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:148"}, {"label": "parseString", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77"}, {"label": "parserOr", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111"}, {"label": "parserReturn", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:164"}, {"label": "parseChar", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95"}, {"label": "parserAnd", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:128"}, {"label": "parser", "kind": 22, "detail": "type parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9"}, {"label": "parseResult", "kind": 22, "detail": "type parseResult('a) = \n  | Exito('a, string)\n  | Fallo(string, string)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "parserFn", "kind": 22, "detail": "type parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:7"}, {"label": "prerr_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:758"}, {"label": "pos_out", "kind": 12, "detail": "out_channel => int", "documentation": "Return the current writing position for the given channel. Does not work on channels opened with the `Open_append` flag \\(returns unspecified results\\).\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:896"}, {"label": "pred", "kind": 12, "detail": "int => int", "documentation": "`pred x` is `x - 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:236"}, {"label": "pos_in", "kind": 12, "detail": "in_channel => int", "documentation": "Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013"}, {"label": "print_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:725"}, {"label": "print_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:732"}, {"label": "prerr_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:768"}, {"label": "print_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:735"}, {"label": "print_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:747"}, {"label": "print_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard output.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:728"}, {"label": "prerr_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard error.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:761"}, {"label": "prerr_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755"}, {"label": "print_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:739"}, {"label": "prerr_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard error, and flush standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:780"}, {"label": "prerr_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:772"}, {"label": "print_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:722"}, {"label": "prerr_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:765"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":167},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     pa\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":503,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":7}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 503, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":504,"method":"completionItem/resolve","params":{"label":"parseChar","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.640153884888ms
Sending response {"id": 504, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":503}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":168},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     par\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":504}}
Read message 
{"jsonrpc":"2.0","id":505,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":8}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0629425048828ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 505, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":505}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":171},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parser\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":506,"method":"completionItem/resolve","params":{"label":"parser","detail":"type parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.0181198120117ms
Sending response {"id": 506, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":507,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":11}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0159740447998ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 507, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":508,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.360012054443ms
Sending response {"id": 508, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":509,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":11},"end":{"line":184,"character":11}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":23},"end":{"line":185,"character":2}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 509, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 5-11[0m[0m:
[1;31mError[0m: Unbound value parser
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 5}, "end": {"line": 184, "character": 11}}, "message": "Error: Unbound value parser\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":172},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserO\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":510,"method":"completionItem/resolve","params":{"label":"parserOr","detail":"(\n  parser(string),\n  parser(string)\n) => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00882148742676ms
Sending response {"id": 510, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":511,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":11}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 511, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":512,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":12}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0650882720947ms
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 512, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":513,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0638961791992ms
Sending response {"id": 513, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":512}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":173},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":514,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":13}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident run
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 514, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser('a),\n  string,\n  continuation('a)\n) => unit", "documentation": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser('a)"}, {"label": "", "documentation": "string"}, {"label": "", "documentation": "continuation('a)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":515,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0669956207275ms
Sending response {"id": 515, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":516,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":13},"end":{"line":184,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 516, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":174},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr()\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":517,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":14}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 517, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":518,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0600814819336ms
Sending response {"id": 518, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 13-15[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 13}, "end": {"line": 184, "character": 15}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":519,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 519, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":520,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":13},"end":{"line":184,"character":15}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 520, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":521,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":13},"end":{"line":184,"character":15}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 521, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":175},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(p)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":522,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 522, "jsonrpc": "2.0", "result": [{"label": "parserMap", "kind": 12, "detail": "(\n  string => string,\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:148"}, {"label": "parseString", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77"}, {"label": "parserOr", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:111"}, {"label": "parserReturn", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:164"}, {"label": "parseChar", "kind": 12, "detail": "string => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95"}, {"label": "parserAnd", "kind": 12, "detail": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:128"}, {"label": "parser", "kind": 22, "detail": "type parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9"}, {"label": "parseResult", "kind": 22, "detail": "type parseResult('a) = \n  | Exito('a, string)\n  | Fallo(string, string)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "parserFn", "kind": 22, "detail": "type parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:7"}, {"label": "prerr_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:758"}, {"label": "pos_out", "kind": 12, "detail": "out_channel => int", "documentation": "Return the current writing position for the given channel. Does not work on channels opened with the `Open_append` flag \\(returns unspecified results\\).\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:896"}, {"label": "pred", "kind": 12, "detail": "int => int", "documentation": "`pred x` is `x - 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:236"}, {"label": "pos_in", "kind": 12, "detail": "in_channel => int", "documentation": "Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013"}, {"label": "print_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:725"}, {"label": "print_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:732"}, {"label": "prerr_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:768"}, {"label": "print_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:735"}, {"label": "print_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:747"}, {"label": "print_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard output.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:728"}, {"label": "prerr_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard error.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:761"}, {"label": "prerr_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755"}, {"label": "print_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:739"}, {"label": "prerr_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard error, and flush standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:780"}, {"label": "prerr_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:772"}, {"label": "print_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:722"}, {"label": "prerr_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:765"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":176},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(pa)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":523,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":16}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 523, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":524,"method":"completionItem/resolve","params":{"label":"parseChar","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:95","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0860691070557ms
Sending response {"id": 524, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 14-16[0m[0m:
[1;31mError[0m: Unbound value pa
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 14}, "end": {"line": 184, "character": 16}}, "message": "Error: Unbound value pa", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":523}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":524}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":180},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parser)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":525,"method":"completionItem/resolve","params":{"label":"parser","detail":"type parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:9","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.00810623168945ms
Sending response {"id": 525, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":16}},"message":"Error: Unbound value pa","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 526, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":527,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":20}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0650882720947ms
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 527, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 14-20[0m[0m:
[1;31mError[0m: Unbound value parser
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 14}, "end": {"line": 184, "character": 20}}, "message": "Error: Unbound value parser\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":528,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 528, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":529,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":20},"end":{"line":184,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 529, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":530,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":20}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 530, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":181},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parserS)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":531,"method":"completionItem/resolve","params":{"label":"parseResult","detail":"type parseResult('a) = \n  | Exito('a, string)\n  | Fallo(string, string)\n","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1","insertTextFormat":1,"kind":22}}
[server] Got a method completionItem/resolve
[server] processing took 0.0100135803223ms
Sending response {"id": 531, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":532,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":21}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 532, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":533,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
Sending response {"id": 533, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 14-21[0m[0m:
[1;31mError[0m: Unbound value parserS
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 14}, "end": {"line": 184, "character": 21}}, "message": "Error: Unbound value parserS\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":534,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":21},"end":{"line":184,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 534, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":535,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":21}},"message":"Error: Unbound value parserS\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 535, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":536,"method":"completionItem/resolve","params":{"label":"parseString","detail":"string => parser(string)","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:77","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0100135803223ms
Sending response {"id": 536, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":537,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":21},"end":{"line":184,"character":21}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":21}},"message":"Error: Unbound value parserS\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 537, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":182},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":538,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":25}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 538, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":539,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
Sending response {"id": 539, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 14-25[0m[0m:
[1;31mError[0m: This expression has type string => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 14}, "end": {"line": 184, "character": 25}}, "message": "Error: This expression has type string => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":540,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":25},"end":{"line":184,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 540, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":541,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":25}},"message":"Error: This expression has type string => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 541, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":183},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":542,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":26}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident parseString
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 542, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "string => parser(string)", "documentation": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "string"}]}]}}
Read message 
{"jsonrpc":"2.0","id":543,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0660419464111ms
Sending response {"id": 543, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":544,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":26},"end":{"line":184,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 544, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":184},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"\"))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":545,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":27}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 545, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":546,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
Sending response {"id": 546, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":547,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":27},"end":{"line":184,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 547, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":185},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":548,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 548, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":549,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":28},"end":{"line":184,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0851154327393ms
Sending response {"id": 549, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":550,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 550, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 5-31[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser('a)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 5}, "end": {"line": 184, "character": 31}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":551,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":31}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 551, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":552,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":29},"end":{"line":184,"character":29}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":31}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0238418579102ms
Sending response {"id": 552, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":553,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":30},"end":{"line":184,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":31}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 553, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":186},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":554,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Nothing completable found :/
Sending response {"id": 554, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":555,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 555, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":556,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":31}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":31}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.105142593384ms
Sending response {"id": 556, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 5-32[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser('a)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 5}, "end": {"line": 184, "character": 32}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":557,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":32}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0171661376953ms
Sending response {"id": 557, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":558,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":31}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":5},"end":{"line":184,"character":32}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser('a)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 558, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":187},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),p)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
type error here [1mFile "[1m", line 185, characters 31-32[0m[0m:
[1;31mError[0m: Unbound value p
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 31}, "end": {"line": 184, "character": 32}}, "message": "Error: Unbound value p", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":191},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parse)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":192},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parser)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":559,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":32}},"message":"Error: Unbound value p","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 559, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":560,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0648498535156ms
Sending response {"id": 560, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":561,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":37},"end":{"line":184,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.128030776978ms
Sending response {"id": 561, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 31-37[0m[0m:
[1;31mError[0m: Unbound value parser
Hint: Did you mean parserOr?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 31}, "end": {"line": 184, "character": 37}}, "message": "Error: Unbound value parser\nHint: Did you mean parserOr?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":562,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":37}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 562, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":563,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":37},"end":{"line":184,"character":37}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":37}},"message":"Error: Unbound value parser\nHint: Did you mean parserOr?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 563, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":193},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parserA)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":564,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 564, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":565,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":38},"end":{"line":184,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 565, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":194},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parserAn)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":566,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 566, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":567,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":39},"end":{"line":184,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 567, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":195},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parserAnd)\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":568,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 568, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":569,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":40},"end":{"line":184,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.06103515625ms
Sending response {"id": 569, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 31-40[0m[0m:
[1;31mError[0m: This expression has type
         (parser(string), parser(string)) => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 31}, "end": {"line": 184, "character": 40}}, "message": "Error: This expression has type\n         (parser(string), parser(string)) => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":197},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":570,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":40}},"message":"Error: This expression has type\n         (parser(string), parser(string)) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0650882720947ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 570, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":571,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":42}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0588893890381ms
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 571, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":572,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 572, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":573,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":42},"end":{"line":184,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 573, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":574,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":41}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
Signature help lident parserAnd
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 574, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 185, characters 40-42[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 184, "character": 40}, "end": {"line": 184, "character": 42}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":575,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":40}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 575, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 184, "character": 31}, "end": {"line": 184, "character": 40}}, "kind": 2}, {"range": {"start": {"line": 145, "character": 14}, "end": {"line": 145, "character": 23}}, "kind": 2}, {"range": {"start": {"line": 127, "character": 4}, "end": {"line": 127, "character": 13}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":576,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":186,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":184,"character":40},"end":{"line":184,"character":42}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 576, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":577,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":31}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
Signature help lident parserOr
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 577, "jsonrpc": "2.0", "result": {"activeParameter": 1, "signatures": [{"label": "(\n  parser(string),\n  parser(string)\n) => parser(string)", "documentation": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "parser(string)"}, {"label": "", "documentation": "parser(string)"}]}]}}
Read message 
{"jsonrpc":"2.0","id":578,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":28}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00810623168945ms
Sending response {"id": 578, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":579,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":28},"end":{"line":184,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 579, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":580,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":31},"end":{"line":184,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 580, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":198},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),\n     parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":581,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 581, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":582,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":5},"end":{"line":185,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0600814819336ms
Sending response {"id": 582, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 186, characters 14-16[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 185, "character": 14}, "end": {"line": 185, "character": 16}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":583,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":187,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":185,"character":14},"end":{"line":185,"character":16}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 583, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":199},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),\n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":584,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 584, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":585,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":8},"end":{"line":185,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.06103515625ms
Sending response {"id": 585, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 186, characters 17-19[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 185, "character": 17}, "end": {"line": 185, "character": 19}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":200},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),\n            parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":586,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":187,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":185,"character":17},"end":{"line":185,"character":19}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0290870666504ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 586, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":587,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0638961791992ms
Sending response {"id": 587, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 186, characters 21-23[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 185, "character": 21}, "end": {"line": 185, "character": 23}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":588,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":12},"end":{"line":185,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 588, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":201},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(parseString(\"a\"),\n                parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":589,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":187,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":185,"character":21},"end":{"line":185,"character":23}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 589, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":590,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0691413879395ms
Sending response {"id": 590, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 186, characters 25-27[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 185, "character": 25}, "end": {"line": 185, "character": 27}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":591,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":16},"end":{"line":185,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 591, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":592,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":187,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":185,"character":25},"end":{"line":185,"character":27}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 592, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":593,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":16},"end":{"line":185,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 593, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":594,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 594, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 184, "character": 14}, "end": {"line": 184, "character": 25}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 37}, "end": {"line": 169, "character": 48}}, "kind": 2}, {"range": {"start": {"line": 169, "character": 11}, "end": {"line": 169, "character": 22}}, "kind": 2}, {"range": {"start": {"line": 76, "character": 4}, "end": {"line": 76, "character": 15}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":595,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":15},"end":{"line":184,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 595, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":596,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":14},"end":{"line":184,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 596, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":202},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":597,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 597, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":598,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":9},"end":{"line":185,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0691413879395ms
Sending response {"id": 598, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 25-27[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 25}, "end": {"line": 186, "character": 27}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":599,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":25},"end":{"line":186,"character":27}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 599, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":600,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":185,"character":9},"end":{"line":185,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 600, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":601,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":26}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 601, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":203},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         \n                parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":602,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 602, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 25-27[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 25}, "end": {"line": 187, "character": 27}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":603,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":189,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":25},"end":{"line":187,"character":27}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 603, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":204},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":604,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 604, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 25-27[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 25}, "end": {"line": 186, "character": 27}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":605,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":25},"end":{"line":186,"character":27}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 605, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":205},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                    parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":606,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0598430633545ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 606, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":206},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":607,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0629425048828ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 607, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":207},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                            parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":608,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 608, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 37-39[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 37}, "end": {"line": 186, "character": 39}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":609,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":37},"end":{"line":186,"character":39}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 609, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":208},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n                        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":610,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 610, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 33-35[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 33}, "end": {"line": 186, "character": 35}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":611,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":33},"end":{"line":186,"character":35}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 611, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":209},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":612,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":8},"end":{"line":186,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 612, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":613,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
Sending response {"id": 613, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 17-19[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 17}, "end": {"line": 186, "character": 19}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":614,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":17},"end":{"line":186,"character":19}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 614, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":615,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 615, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 184, "character": 5}, "end": {"line": 184, "character": 13}}, "kind": 2}, {"range": {"start": {"line": 124, "character": 14}, "end": {"line": 124, "character": 22}}, "kind": 2}, {"range": {"start": {"line": 110, "character": 4}, "end": {"line": 110, "character": 12}}, "kind": 2}]}
Read message 
{"jsonrpc":"2.0","id":616,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":184,"character":8},"end":{"line":184,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 616, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":210},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         \n         parseString(\"a\"),\n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":617,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0247955322266ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 617, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 17-19[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 17}, "end": {"line": 187, "character": 19}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":618,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":189,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":17},"end":{"line":187,"character":19}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 618, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":211},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n                  parseString(\"a\"),\n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":619,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 619, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":212},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":620,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 620, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":621,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":26}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 621, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 17-19[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 17}, "end": {"line": 186, "character": 19}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":622,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":17},"end":{"line":186,"character":19}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 622, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":213},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         \n        parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":623,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 623, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 17-19[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 17}, "end": {"line": 187, "character": 19}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":624,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":189,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":17},"end":{"line":187,"character":19}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 624, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":214},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd())\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":625,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":9},"end":{"line":186,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0629425048828ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 625, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":626,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 626, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 18-20[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 18}, "end": {"line": 186, "character": 20}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":627,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":188,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":18},"end":{"line":186,"character":20}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 627, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":628,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":9},"end":{"line":186,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 628, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":629,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":21},"end":{"line":186,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 629, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":630,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":20},"end":{"line":186,"character":20}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":18},"end":{"line":186,"character":20}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 630, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":631,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":186,"character":19},"end":{"line":186,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":18},"end":{"line":186,"character":20}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 631, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":215},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             \n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":632,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 632, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 18-44[0m[0m:
[1;31mError[0m: This expression has type unit but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 18}, "end": {"line": 188, "character": 10}}, "message": "Error: This expression has type unit but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":633,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":18},"end":{"line":188,"character":10}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 633, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":216},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":634,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 634, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 13-15[0m[0m:
[1;31mError[0m: This expression has type {. } but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 13}, "end": {"line": 187, "character": 15}}, "message": "Error: This expression has type {. } but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":635,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":14},"end":{"line":187,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":18},"end":{"line":188,"character":10}},"message":"Error: This expression has type unit but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 635, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":636,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":15}},"message":"Error: This expression has type {. } but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 636, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":637,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":14},"end":{"line":187,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":15}},"message":"Error: This expression has type {. } but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 637, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":217},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {f}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":638,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 638, "jsonrpc": "2.0", "result": [{"label": "fn", "kind": 5, "detail": "fn: 'a0 parserFn\n\ntype parser('a) = {fn: parserFn('a), nombre: string}", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "format_of_string", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => format6('a, 'b, 'c, 'd, 'e, 'f)", "documentation": "`format_of_string s` returns a format string read from the string literal `s`. Note: `format_of_string` can not convert a string argument that is not a literal. If you need this functionality, use the more general format_from_string function.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1169"}, {"label": "failwith", "kind": 12, "detail": "string => 'a", "documentation": "Raise exception `Failure` with the given string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:39"}, {"label": "float", "kind": 12, "detail": "int => float", "documentation": "Same as float_of_int.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:538"}, {"label": "fst", "kind": 12, "detail": "(('a, 'b)) => 'a", "documentation": "Return the first component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:684"}, {"label": "float_of_int", "kind": 12, "detail": "int => float", "documentation": "Convert an integer to floating-point.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:541"}, {"label": "flush", "kind": 12, "detail": "out_channel => unit", "documentation": "Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:839"}, {"label": "flush_all", "kind": 12, "detail": "unit => unit", "documentation": "Flush all open output channels; ignore errors.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:845"}, {"label": "frexp", "kind": 12, "detail": "float => (float, int)", "documentation": "`frexp f` returns the pair of the significant and the exponent of `f`. When `f` is zero, the significant `x` and the exponent `n` of `f` are equal to zero. When `f` is non-zero, they are defined by `f = x *. 2 ** n` and `0.5 <= x < 1.0`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:524"}, {"label": "float_of_string", "kind": 12, "detail": "string => float", "documentation": "Convert the given string to a float. Raise `Failure \"float_of_string\"` if the given string is not a valid representation of a float.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:677"}, {"label": "floor", "kind": 12, "detail": "float => float", "documentation": "Round below to an integer value. `floor f` returns the greatest integer value less than or equal to `f`. The result is returned as a float.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:418"}, {"label": "format4", "kind": 22, "detail": "type format4('a, 'b, 'c, 'd) = format6(\n  'a,\n  'b,\n  'c,\n  'c,\n  'c,\n  'd\n)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1162"}, {"label": "format", "kind": 22, "detail": "type format('a, 'b, 'c) = format4('a, 'b, 'c, 'c)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1164"}, {"label": "format6", "kind": 22, "detail": "type format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) = CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1159"}, {"label": "fpclass", "kind": 22, "detail": "type fpclass = \n  | FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\n", "documentation": "The five classes of floating-point numbers, as determined by the classify_float function.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:592"}]}
Read message 
{"jsonrpc":"2.0","id":639,"method":"completionItem/resolve","params":{"label":"failwith","detail":"string => 'a","documentation":"Raise exception `Failure` with the given string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:39","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00882148742676ms
Sending response {"id": 639, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":640,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 640, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":641,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":15},"end":{"line":187,"character":15}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":15}},"message":"Error: This expression has type {. } but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.548839569092ms
Sending response {"id": 641, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":218},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":642,"method":"completionItem/resolve","params":{"label":"fn","detail":"fn: 'a0 parserFn\n\ntype parser('a) = {fn: parserFn('a), nombre: string}","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1","insertTextFormat":1,"kind":5}}
[server] Got a method completionItem/resolve
[server] processing took 0.00810623168945ms
Sending response {"id": 642, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":643,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 643, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":644,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":16},"end":{"line":187,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0679492950439ms
Sending response {"id": 644, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":219},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":645,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.110864639282ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 645, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":646,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":17},"end":{"line":187,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0808238983154ms
Sending response {"id": 646, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":220},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:P}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":647,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 647, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "Pruebas", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printf", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Printexc", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Pervasives", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":221},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Pa}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":648,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 648, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":222},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Par}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":223},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Pars}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":649,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 649, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}, {"label": "Parsing", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":224},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parse}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":650,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 650, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":225},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":651,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
Sending response {"id": 651, "jsonrpc": "2.0", "result": [{"label": "Parser", "kind": 4, "detail": "Parser((string, continuation('a)) => unit)\n\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:1"}, {"label": "ParserC", "kind": 9, "detail": "module", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt:1"}, {"label": "ParserLibrary", "kind": 9, "detail": "file module", "documentation": "No docs\n\nwait for uri:1"}]}
Read message 
{"jsonrpc":"2.0","id":652,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 652, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":653,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":23},"end":{"line":187,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.152826309204ms
Sending response {"id": 653, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 17-23[0m[0m:
[1;31mError[0m: The constructor Parser expects 1 argument(s),
       but is applied here to 0 argument(s)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 17}, "end": {"line": 187, "character": 23}}, "message": "Error: The constructor Parser expects 1 argument(s),\n       but is applied here to 0 argument(s)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":654,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":17},"end":{"line":187,"character":23}},"message":"Error: The constructor Parser expects 1 argument(s),\n       but is applied here to 0 argument(s)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0650882720947ms
Sending response {"id": 654, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":655,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":23},"end":{"line":187,"character":23}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":17},"end":{"line":187,"character":23}},"message":"Error: The constructor Parser expects 1 argument(s),\n       but is applied here to 0 argument(s)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 655, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":226},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser()}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":656,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":24}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident Parser
Found a type signature
Sending response {"id": 656, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":657,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0591278076172ms
Sending response {"id": 657, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":658,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":24},"end":{"line":187,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 658, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":656}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":227},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s)}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":659,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 659, "jsonrpc": "2.0", "result": [{"label": "s", "kind": 12, "detail": "(string, continuation(string)) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178"}, {"label": "s2", "kind": 12, "detail": "(string, continuation(string)) => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:175"}, {"label": "s1", "kind": 12, "detail": "parser(string)", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:174"}, {"label": "sin", "kind": 12, "detail": "float => float", "documentation": "Sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:373"}, {"label": "stdout", "kind": 12, "detail": "out_channel", "documentation": "The standard output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:713"}, {"label": "set_binary_mode_in", "kind": 12, "detail": "(in_channel, bool) => unit", "documentation": "`set_binary_mode_in ic true` sets the channel `ic` to binary mode: no translations take place during input. `set_binary_mode_out ic false` sets the channel `ic` to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from `\\r\\n` to `\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1033"}, {"label": "stdin", "kind": 12, "detail": "in_channel", "documentation": "The standard input for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:710"}, {"label": "string_of_int", "kind": 12, "detail": "int => string", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:660"}, {"label": "stderr", "kind": 12, "detail": "out_channel", "documentation": "The standard error output for the process.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:716"}, {"label": "snd", "kind": 12, "detail": "(('a, 'b)) => 'b", "documentation": "Return the second component of a pair.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:687"}, {"label": "string_of_format", "kind": 12, "detail": "format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "documentation": "Converts a format string into a string.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1166"}, {"label": "seek_in", "kind": 12, "detail": "(in_channel, int) => unit", "documentation": "`seek_in chan pos` sets the current reading position to `pos` for channel `chan`. This works only for regular files. On files of other kinds, the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1008"}, {"label": "string_of_float", "kind": 12, "detail": "float => string", "documentation": "Return the string representation of a floating-point number.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:674"}, {"label": "sqrt", "kind": 12, "detail": "float => float", "documentation": "Square root.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:346"}, {"label": "set_binary_mode_out", "kind": 12, "detail": "(out_channel, bool) => unit", "documentation": "`set_binary_mode_out oc true` sets the channel `oc` to binary mode: no translations take place during output. `set_binary_mode_out oc false` sets the channel `oc` to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from `\\n` to `\\r\\n`. This function has no effect under operating systems that do not distinguish between text mode and binary mode.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:917"}, {"label": "string_of_bool", "kind": 12, "detail": "bool => string", "documentation": "Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:649"}, {"label": "succ", "kind": 12, "detail": "int => int", "documentation": "`succ x` is `x + 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:233"}, {"label": "sinh", "kind": 12, "detail": "float => float", "documentation": "Hyperbolic sine. Argument is in radians.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:407"}, {"label": "seek_out", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "`seek_out chan pos` sets the current writing position to `pos` for channel `chan`. This works only for regular files. On files of other kinds \\(such as terminals, pipes and sockets\\), the behavior is unspecified.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:890"}]}
Read message 
{"jsonrpc":"2.0","id":660,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":25}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00691413879395ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Signature help lident Parser
Found a type signature
Sending response {"id": 660, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":661,"method":"completionItem/resolve","params":{"label":"s","detail":"(string, continuation(string)) => unit","documentation":"No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re:178","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0669956207275ms
Sending response {"id": 661, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":662,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 662, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 13-27[0m[0m:
[1;31mError[0m: Some record fields are undefined: nombre
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 13}, "end": {"line": 187, "character": 27}}, "message": "Error: Some record fields are undefined: nombre", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":663,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":25},"end":{"line":187,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 663, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":664,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":26},"end":{"line":187,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 664, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":663}}
Read message 
{"jsonrpc":"2.0","id":665,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":27}},"message":"Error: Some record fields are undefined: nombre","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 665, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":666,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":26},"end":{"line":187,"character":26}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":27}},"message":"Error: Some record fields are undefined: nombre","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 666, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":228},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":667,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Nothing completable found :/
Sending response {"id": 667, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":668,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 668, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":669,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":27},"end":{"line":187,"character":27}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":13},"end":{"line":187,"character":27}},"message":"Error: Some record fields are undefined: nombre","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0708103179932ms
Sending response {"id": 669, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":229},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),n}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":230},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),no}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":231},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nom}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":670,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 670, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":671,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":30},"end":{"line":187,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 671, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 27-30[0m[0m:
[1;31mError[0m: This record expression is expected to have type parser(string)
       The field nom does not belong to type parser
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 27}, "end": {"line": 187, "character": 30}}, "message": "Error: This record expression is expected to have type parser(string)\n       The field nom does not belong to type parser", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":672,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":27},"end":{"line":187,"character":30}},"message":"Error: This record expression is expected to have type parser(string)\n       The field nom does not belong to type parser","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 672, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":673,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":30},"end":{"line":187,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":27},"end":{"line":187,"character":30}},"message":"Error: This record expression is expected to have type parser(string)\n       The field nom does not belong to type parser","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 673, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":232},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nomb}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":674,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 674, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":675,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":31},"end":{"line":187,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 675, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":234},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":676,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 676, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":677,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":33},"end":{"line":187,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0810623168945ms
Sending response {"id": 677, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 27-33[0m[0m:
[1;31mError[0m: Unbound value nombre
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 27}, "end": {"line": 187, "character": 33}}, "message": "Error: Unbound value nombre", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":678,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":27},"end":{"line":187,"character":33}},"message":"Error: Unbound value nombre","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 678, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":679,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":33},"end":{"line":187,"character":33}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":27},"end":{"line":187,"character":33}},"message":"Error: Unbound value nombre","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 679, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":235},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":236},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"}\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":680,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 680, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":681,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":35},"end":{"line":187,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 681, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 9-68[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 9}, "end": {"line": 188, "character": 10}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":682,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 682, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":683,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":35},"end":{"line":187,"character":35}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 683, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":684,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":36}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Got a loc for pos
Sending response {"id": 684, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":685,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":36},"end":{"line":187,"character":36}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 685, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":686,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":35},"end":{"line":187,"character":35}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 686, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":687,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":36},"end":{"line":187,"character":36}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 687, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":688,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":35},"end":{"line":187,"character":35}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 688, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":689,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":36},"end":{"line":187,"character":36}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 689, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":690,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":37},"end":{"line":187,"character":37}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 690, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":691,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":36}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0138282775879ms
Got a loc for pos
Sending response {"id": 691, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":692,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":36},"end":{"line":187,"character":36}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 692, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":693,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":37},"end":{"line":187,"character":37}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 693, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":237},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":694,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Nothing completable found :/
Sending response {"id": 694, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":695,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 695, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":696,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":38},"end":{"line":187,"character":38}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 696, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 9-69[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 9}, "end": {"line": 188, "character": 10}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":238},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},1\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":697,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0660419464111ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 697, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":698,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":39},"end":{"line":187,"character":39}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0779628753662ms
Sending response {"id": 698, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 188, characters 38-39[0m[0m:
[1;31mError[0m: This expression has type int but an expression was expected of type
         parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 187, "character": 38}, "end": {"line": 187, "character": 39}}, "message": "Error: This expression has type int but an expression was expected of type\n         parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":699,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":38},"end":{"line":187,"character":39}},"message":"Error: This expression has type int but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 699, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":239},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":700,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.06103515625ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 700, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 9-69[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 9}, "end": {"line": 188, "character": 10}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":701,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":38},"end":{"line":187,"character":38}},"context":{"diagnostics":[{"range":{"start":{"line":187,"character":38},"end":{"line":187,"character":39}},"message":"Error: This expression has type int but an expression was expected of type\n         parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 701, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":702,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":190,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 702, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":703,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":38},"end":{"line":187,"character":38}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":188,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 703, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":240},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             \n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":704,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.113010406494ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 704, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 187, characters 9-83[0m[0m:
[1;31mError[0m: This expression has type parser(string) => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 186, "character": 9}, "end": {"line": 189, "character": 10}}, "message": "Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":705,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":189,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 705, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":241},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             p\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":706,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.255107879639ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 706, "jsonrpc": "2.0", "result": [{"label": "prerr_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:758"}, {"label": "pos_out", "kind": 12, "detail": "out_channel => int", "documentation": "Return the current writing position for the given channel. Does not work on channels opened with the `Open_append` flag \\(returns unspecified results\\).\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:896"}, {"label": "pred", "kind": 12, "detail": "int => int", "documentation": "`pred x` is `x - 1`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:236"}, {"label": "pos_in", "kind": 12, "detail": "in_channel => int", "documentation": "Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013"}, {"label": "print_string", "kind": 12, "detail": "string => unit", "documentation": "Print a string on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:725"}, {"label": "print_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:732"}, {"label": "prerr_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:768"}, {"label": "print_float", "kind": 12, "detail": "float => unit", "documentation": "Print a floating-point number, in decimal, on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:735"}, {"label": "print_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:747"}, {"label": "print_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard output.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:728"}, {"label": "prerr_bytes", "kind": 12, "detail": "bytes => unit", "documentation": "Print a byte sequence on standard error.\n\nSince: 4.02.0\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:761"}, {"label": "prerr_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755"}, {"label": "print_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:739"}, {"label": "prerr_newline", "kind": 12, "detail": "unit => unit", "documentation": "Print a newline character on standard error, and flush standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:780"}, {"label": "prerr_endline", "kind": 12, "detail": "string => unit", "documentation": "No docs\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:772"}, {"label": "print_char", "kind": 12, "detail": "char => unit", "documentation": "Print a character on standard output.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:722"}, {"label": "prerr_int", "kind": 12, "detail": "int => unit", "documentation": "Print an integer, in decimal, on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:765"}]}
Read message 
{"jsonrpc":"2.0","id":707,"method":"completionItem/resolve","params":{"label":"pos_in","detail":"in_channel => int","documentation":"Return the current reading position for the given channel.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1013","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.00882148742676ms
Sending response {"id": 707, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":242},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             pa\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":708,"method":"completionItem/resolve","params":{"label":"prerr_char","detail":"char => unit","documentation":"Print a character on standard error.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:755","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0112056732178ms
Sending response {"id": 708, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":708}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":244},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             pars\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":709,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 709, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":710,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":17},"end":{"line":188,"character":17}},"context":{"diagnostics":[{"range":{"start":{"line":186,"character":9},"end":{"line":189,"character":10}},"message":"Error: This expression has type parser(string) => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.06103515625ms
Sending response {"id": 710, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 189, characters 13-17[0m[0m:
[1;31mError[0m: Unbound value pars
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 17}}, "message": "Error: Unbound value pars", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":245},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parse\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":711,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 711, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":712,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":188,"character":13},"end":{"line":188,"character":17}},"message":"Error: Unbound value pars","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 712, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":713,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0591278076172ms
Sending response {"id": 713, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 189, characters 13-18[0m[0m:
[1;31mError[0m: Unbound value parse
Hint: Did you mean raise?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 18}}, "message": "Error: Unbound value parse\nHint: Did you mean raise?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":714,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":18},"end":{"line":188,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 714, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":715,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":188,"character":13},"end":{"line":188,"character":18}},"message":"Error: Unbound value parse\nHint: Did you mean raise?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 715, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":246},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseS\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":716,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.133037567139ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 716, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":247},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseSt\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":249},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseStri\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":717,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 717, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":718,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":22},"end":{"line":188,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0998973846436ms
Sending response {"id": 718, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 189, characters 13-22[0m[0m:
[1;31mError[0m: Unbound value parseStri
Hint: Did you mean parseString?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 22}}, "message": "Error: Unbound value parseStri\nHint: Did you mean parseString?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":250},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":719,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":188,"character":13},"end":{"line":188,"character":22}},"message":"Error: Unbound value parseStri\nHint: Did you mean parseString?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 719, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":720,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0622272491455ms
Sending response {"id": 720, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":721,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":24},"end":{"line":188,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.107049942017ms
Sending response {"id": 721, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 189, characters 13-24[0m[0m:
[1;31mError[0m: This expression has type string => parser(string)
       but an expression was expected of type parser(string)
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 24}}, "message": "Error: This expression has type string => parser(string)\n       but an expression was expected of type parser(string)", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":251},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString()\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":722,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":188,"character":13},"end":{"line":188,"character":24}},"message":"Error: This expression has type string => parser(string)\n       but an expression was expected of type parser(string)","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 722, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":723,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":25}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0600814819336ms
Signature help lident parseString
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Found a type signature
Sending response {"id": 723, "jsonrpc": "2.0", "result": {"activeParameter": 0, "signatures": [{"label": "string => parser(string)", "documentation": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}, "parameters": [{"label": "", "documentation": "string"}]}]}}
Read message 
{"jsonrpc":"2.0","id":724,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 724, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":725,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":25},"end":{"line":188,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0741481781006ms
Sending response {"id": 725, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":252},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"\")\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":726,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":26}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00786781311035ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 726, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":727,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0669956207275ms
Sending response {"id": 727, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":728,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":26},"end":{"line":188,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 728, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":726}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":253},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":729,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":27}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0720024108887ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 729, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":730,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0631809234619ms
Sending response {"id": 730, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 20-170[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type continuation(string) => unit
       Type string is not compatible with type
         continuation(string) = parseResult(string) => unit 
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 20}, "end": {"line": 190, "character": 2}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":731,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":27},"end":{"line":188,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 731, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":732,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 732, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":733,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":27},"end":{"line":188,"character":27}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 733, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":734,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":29},"end":{"line":188,"character":29}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 734, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":735,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":10},"end":{"line":189,"character":10}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 735, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":736,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":9},"end":{"line":189,"character":9}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 736, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":737,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":10},"end":{"line":189,"character":10}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0221729278564ms
Sending response {"id": 737, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":738,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":11},"end":{"line":189,"character":11}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 738, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":254},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":739,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":189,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Nothing completable found :/
Sending response {"id": 739, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":740,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 740, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 20-171[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type continuation(string) => unit
       Type string is not compatible with type
         continuation(string) = parseResult(string) => unit 
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 20}, "end": {"line": 190, "character": 2}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":741,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":12},"end":{"line":189,"character":12}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 741, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":255},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),1\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":742,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 742, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":743,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":13},"end":{"line":189,"character":13}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0689029693604ms
Sending response {"id": 743, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 190, characters 12-13[0m[0m:
[1;31mError[0m: This expression has type int but an expression was expected of type
         string
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 189, "character": 12}, "end": {"line": 189, "character": 13}}, "message": "Error: This expression has type int but an expression was expected of type\n         string", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":744,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":189,"character":12},"end":{"line":189,"character":13}},"message":"Error: This expression has type int but an expression was expected of type\n         string","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 744, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":745,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":13},"end":{"line":189,"character":13}},"context":{"diagnostics":[{"range":{"start":{"line":189,"character":12},"end":{"line":189,"character":13}},"message":"Error: This expression has type int but an expression was expected of type\n         string","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 745, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":256},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":257},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         ))\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":746,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 746, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 20-170[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type continuation(string) => unit
       Type string is not compatible with type
         continuation(string) = parseResult(string) => unit 
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 20}, "end": {"line": 190, "character": 2}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":747,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":11},"end":{"line":189,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 747, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":748,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":191,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 748, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":258},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":749,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":189,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0138282775879ms
Nothing completable found :/
Sending response {"id": 749, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":750,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 750, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":751,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":12},"end":{"line":189,"character":12}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":190,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0679492950439ms
Sending response {"id": 751, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 20-171[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type continuation(string) => unit
       Type string is not compatible with type
         continuation(string) = parseResult(string) => unit 
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 20}, "end": {"line": 190, "character": 2}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":259},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n         \n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":752,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
Sending response {"id": 752, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
type error here [1mFile "[1m", line 184, characters 20-181[0m[0m:
[1;31mError[0m: This expression has type (string, continuation(string)) => unit
       but an expression was expected of type continuation(string) => unit
       Type string is not compatible with type
         continuation(string) = parseResult(string) => unit 
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": [{"range": {"start": {"line": 183, "character": 20}, "end": {"line": 191, "character": 2}}, "message": "Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":753,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":0,"character":0},"end":{"line":192,"character":57}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":191,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 753, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":260},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n         a\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":754,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":190,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Opens folkz > 0 
Package opens Pervasives ParserLibrary ParserLibrary
Package opens Pervasives ParserLibrary ParserLibrary
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.cmti src /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
FINDING /home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt src 
Opens nows 3 file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
---------------- LOCAL VAL
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
 - Completing in file:///home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/ParserLibrary.cmt
 -- not capitalized
Sending response {"id": 754, "jsonrpc": "2.0", "result": [{"label": "atan2", "kind": 12, "detail": "(float, float) => float", "documentation": "`atan2 y x` returns the arc tangent of `y /. x`. The signs of `x` and `y` are used to determine the quadrant of the result. Result is in radians and is between `-pi` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:391"}, {"label": "asr", "kind": 12, "detail": "(int, int) => int", "documentation": "`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302"}, {"label": "abs", "kind": 12, "detail": "int => int", "documentation": "Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265"}, {"label": "asin", "kind": 12, "detail": "float => float", "documentation": "Arc sine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:383"}, {"label": "acos", "kind": 12, "detail": "float => float", "documentation": "Arc cosine. The argument must fall within the range `[-1.0, 1.0]`. Result is in radians and is between `0.0` and `pi`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:379"}, {"label": "atan", "kind": 12, "detail": "float => float", "documentation": "Arc tangent. Result is in radians and is between `-pi/2` and `pi/2`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:387"}, {"label": "abs_float", "kind": 12, "detail": "float => float", "documentation": "`abs_float f` returns the absolute value of `f`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:424"}, {"label": "at_exit", "kind": 12, "detail": "unit => unit => unit", "documentation": "Register the given function to be called at program termination time. The functions registered with `at_exit` will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in 'last in, first out' order: the function most recently added with `at_exit` is called first.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:1202"}]}
Read message 
{"jsonrpc":"2.0","id":755,"method":"completionItem/resolve","params":{"label":"abs","detail":"int => int","documentation":"Return the absolute value of the argument. Note that this may be negative if the argument is `min_int`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:265","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0100135803223ms
Sending response {"id": 755, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":261},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n         ar\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":756,"method":"completionItem/resolve","params":{"label":"asr","detail":"(int, int) => int","documentation":"`n asr m` shifts `n` to the right by `m` bits. This is an arithmetic shift: the sign bit of `n` is replicated. The result is unspecified if `m < 0` or `m >= bitsize`.\n\n\n\nfile:///home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml/pervasives.mli:302","insertTextFormat":1,"kind":12}}
[server] Got a method completionItem/resolve
[server] processing took 0.0100135803223ms
Sending response {"id": 756, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":756}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":262},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":757,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 757, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":758,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":190,"character":12},"end":{"line":190,"character":12}},"context":{"diagnostics":[{"range":{"start":{"line":183,"character":20},"end":{"line":191,"character":2}},"message":"Error: This expression has type (string, continuation(string)) => unit\n       but an expression was expected of type continuation(string) => unit\n       Type string is not compatible with type\n         continuation(string) = parseResult(string) => unit ","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0669956207275ms
Sending response {"id": 758, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":759,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":190,"character":12},"end":{"line":190,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 759, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":760,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 760, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":761,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 761, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":762,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 762, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":763,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1217 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 763, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 13}, "end": {"line": 183, "character": 16}}, "contents": {"kind": "markdown", "value": "```\nstring\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":764,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 764, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 20}, "end": {"line": 183, "character": 23}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":765,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 765, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":766,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 766, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":767,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 767, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":768,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":34}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 768, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 187, "character": 34}, "end": {"line": 187, "character": 36}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":769,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":34}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Got a loc for pos
Sending response {"id": 769, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":770,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":34},"end":{"line":187,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 770, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":771,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 771, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":772,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 772, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":773,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":35},"end":{"line":187,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 773, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":267},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parsr\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":774,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 774, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":775,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":40},"end":{"line":187,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0801086425781ms
Sending response {"id": 775, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":776,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":39}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Got a loc for pos
Sending response {"id": 776, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":268},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parser\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":777,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 777, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":778,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":40},"end":{"line":187,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0889301300049ms
Sending response {"id": 778, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":779,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":41}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Got a loc for pos
Sending response {"id": 779, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":780,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":41},"end":{"line":187,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 780, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":269},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":781,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 781, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":782,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":187,"character":42},"end":{"line":187,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.075101852417ms
Sending response {"id": 782, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":269},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"patakon\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":269}}}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
[1/2] [34mBuilding[39m [2msrc/ParserC.mlast[22m
[2/2] [34mBuilding[39m [2msrc/ParserC.mlast.d[22m
[1/1] [34mBuilding[39m [2msrc/ParserC-ParserLibrary.cmj[22m
>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":783,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 783, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":784,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 784, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":785,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Got a loc for pos
Sending response {"id": 785, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":786,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":192,"character":26},"end":{"line":192,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 786, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":270},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"p\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":787,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 787, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":788,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":192,"character":27},"end":{"line":192,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0650882720947ms
Sending response {"id": 788, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":271},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"pa\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":275},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"parser\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":789,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 789, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":790,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":192,"character":32},"end":{"line":192,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0619888305664ms
Sending response {"id": 790, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":789}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":276},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":791,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 791, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":792,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":192,"character":33},"end":{"line":192,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0629425048828ms
Sending response {"id": 792, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":790}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":276},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n )\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":276}}}
Read message 
{"jsonrpc":"2.0","id":793,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 793, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 15}, "end": {"line": 192, "character": 16}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
ninja: no work to do.
>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":794,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 794, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 8}, "end": {"line": 192, "character": 14}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":795,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 795, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 8}, "end": {"line": 192, "character": 14}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":796,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":34}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 796, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":797,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 797, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 25}, "end": {"line": 192, "character": 34}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":798,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":31}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 798, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 187, "character": 27}, "end": {"line": 187, "character": 33}}, "contents": {"kind": "markdown", "value": "```\nparser('a)\n```\n\n```\ntype parser('a) = {fn: parserFn('a), nombre: string}\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":799,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":41}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 799, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 187, "character": 34}, "end": {"line": 187, "character": 43}}, "contents": {"kind": "markdown", "value": "string"}}}
Read message 
{"jsonrpc":"2.0","id":800,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":189,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 800, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":801,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 801, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 24}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":802,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 802, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":803,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 803, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":804,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 804, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":805,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 805, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 185, "character": 9}, "end": {"line": 185, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":806,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0181198120117ms
Trying for declared Value 1180 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 806, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 184, "character": 5}, "end": {"line": 184, "character": 13}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":807,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 807, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":808,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":186,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.028133392334ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 808, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 186, "character": 9}, "end": {"line": 186, "character": 18}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":809,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":192,"character":1}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 809, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 192, "character": 0}, "end": {"line": 192, "character": 3}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":810,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":191,"character":1}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 810, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":811,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":191,"character":2},"end":{"line":191,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 811, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":812,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":191,"character":1},"end":{"line":191,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 812, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":277},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg\n)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":813,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 813, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":814,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":191,"character":0},"end":{"line":191,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0669956207275ms
Sending response {"id": 814, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":278},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n         )),\n         arg)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":815,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 815, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":816,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":190,"character":12},"end":{"line":190,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 816, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":817,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":189,"character":12}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 817, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":818,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":12},"end":{"line":189,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 818, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":819,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":9},"end":{"line":189,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 819, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":279},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n        )),\n         arg)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":820,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 820, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":821,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":189,"character":8},"end":{"line":189,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.108003616333ms
Sending response {"id": 821, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":280},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\")\n    )),\n         arg)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":282},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\"))),\n         arg)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","id":822,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 822, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Array, String, Js, Hashtbl, Pervasives, List", "command": ""}}, {"range": {"start": {"line": 112, "character": 8}, "end": {"line": 112, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 46, "character": 9}, "end": {"line": 46, "character": 16}}, "command": {"title": "3 uses. values: {add, create, find_all}", "command": ""}}, {"range": {"start": {"line": 129, "character": 8}, "end": {"line": 129, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}, {"range": {"start": {"line": 96, "character": 8}, "end": {"line": 96, "character": 14}}, "command": {"title": "2 uses. values: {length, sub}", "command": ""}}, {"range": {"start": {"line": 149, "character": 8}, "end": {"line": 149, "character": 14}}, "command": {"title": "1 uses. values: {length}", "command": ""}}]}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":823,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":29},"end":{"line":188,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 823, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":824,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":32}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 824, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":825,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"range":{"start":{"line":188,"character":32},"end":{"line":188,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 825, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":826,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 826, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 185, "character": 9}, "end": {"line": 185, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":827,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":186,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Trying for declared Value 1187 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 827, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 186, "character": 9}, "end": {"line": 186, "character": 18}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser(string),\n  parser(string)\n) => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":828,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":188,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 828, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 188, "character": 13}, "end": {"line": 188, "character": 24}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":829,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":186,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 829, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":830,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 830, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 187, "character": 17}, "end": {"line": 187, "character": 23}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":831,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 831, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":282},"contentChanges":[{"text":"type parseResult ('a) = \n    | Exito ('a, string)\n    | Fallo (string, string)\n\ntype continuation('a) = parseResult('a) => unit\n\ntype  parserFn ('a) = Parser(string => continuation('a) => unit)\n\ntype parser('a) = {\n    fn: parserFn('a),\n    nombre: string\n}\n\nlet compose = (f, g) =>\n    x => g(f(x))\n\nlet ( -| ) = compose\n\nlet run = (parser, cadena, k) => \nswitch(parser.fn) {\n| Parser(fn) => fn(cadena, k)\n}\n\nlet execParser = (parser, cadena) => {\n    let resultados = ref ([]);\n    run (parser, cadena,\n        fun\n        | Exito(v,_) => {resultados := [v, ...resultados^]}\n        | _ => () )\n    resultados^ |> Array.of_list\n}\n\nlet memo = fn => {\n    let tabla = Hashtbl.create(10);\n    arg =>\n        switch (Hashtbl.find(tabla, arg)) {\n        | exception Not_found => {\n            let valor = fn(arg);\n            Hashtbl.add(tabla, arg, valor);\n            valor\n        }\n        | valor => valor\n        };\n    };\n\nlet memoCPS = fn => {\n    open Hashtbl;\n    let isResultSaved = (tabla,cadena:string, result:parseResult('a)) => \n        find_all(tabla, cadena) |> List.mem(result)\n    \n    let tablaContinuaciones = create(10);\n    let tablaResultados = create(10);\n    let innerFn = Parser((arg, k) => {\n        let listadoContinuaciones =  find_all(tablaContinuaciones, arg);\n        if (List.length(listadoContinuaciones) == 0) {\n            add(tablaContinuaciones, arg, k);\n            run(fn, arg,\n                result => {\n                    switch (isResultSaved(tablaResultados, arg, result)) {\n                    | false => {\n                        add(tablaResultados, arg, result);\n                        let lista =  find_all(tablaContinuaciones, arg);\n                        lista |> List.iter(cont=> cont(result)) \n                        }\n                    | _ => ()\n                    };\n                })\n        } else {\n                add(tablaContinuaciones, arg, k)\n                find_all(tablaResultados,arg) |> List.iter(valor=>k(valor))\n        }\n    })\n    let innerParser = {fn:innerFn,nombre:fn.nombre}\n    innerParser\n}\n\nlet parseString = memo(patron => {\n    let innerFn = (cadena,k:continuation('a)) => {\n        let longPatron = String.length(patron);\n        let longCadena = String.length(cadena);\n        if (longPatron > longCadena) {\n            k(Fallo(\"Final de la cadena\", cadena))\n        } else {\n            let subcadena = String.sub(cadena,0, longPatron);\n            if (subcadena == patron) {\n                k(Exito(subcadena, String.sub(cadena, longPatron, longCadena-longPatron)))\n            } else {\n                k(Fallo(\"No esperado\", cadena))\n            }\n        }\n    };\n    memoCPS({fn:Parser(innerFn), nombre:\"parseString-\" ++ patron})\n})\n\nlet parseChar = memo (caracter =>{\n    let innerFn = (cadena:string, k:continuation('a)) => {\n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => let car1 = sub(cadena, 0,1)\n                let resto = sub(cadena, 1, length(cadena) - 1)\n            if (car1 == caracter) \n                k(Exito(caracter, resto))\n            else \n            k(Fallo({j|Esperaba $caracter y obtuve $car1|j}, cadena))\n        })\n    };\n    memoCPS({fn:Parser(innerFn),nombre:\"parseChar-\"++caracter})\n})\n\nlet parserOr = memo((p1:parser(string), p2) =>{\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => {\n                run(p1, cadena, k);\n                run(p2, cadena, k);\n                ();\n            }\n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserOr-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( <|> ) = parserOr\n\n\nlet parserAnd = memo((p1:parser(string), p2:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n        switch (length(cadena)) {\n        | 0 => k(Fallo(\"Final de la cadena\", cadena))\n        | _ => run (p1, cadena,\n                    fun\n                    | Exito(valor1, resto1) =>\n                        run (p2, resto1,\n                            fun \n                            | Exito (valor2, resto2) => k(Exito(valor1 ++ valor2 , resto2))\n                            | Fallo (_, _) as e1 => k(e1))\n                    | Fallo(_, _) as e1 => k(e1))\n            \n        });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserAnd-\"++p1.nombre++\"-\"++p2.nombre})\n})\n\nlet ( >-> ) = parserAnd;\n\nlet parserMap = memo((fn:string=>string, p:parser(string)) => {\n    let innerFn = (cadena, k) => \n        String.(\n            switch (length(cadena)) {\n            | 0 => k(Fallo(\"Final de la cadena\", cadena))\n            | _ =>\n                    run(p, cadena,\n                        fun\n                        | Exito(valor, resto) => k(Exito(fn(valor), resto))\n                        | Fallo(_,_) as e1 => k(e1))\n            });\n    memoCPS({fn:Parser(innerFn),nombre:\"parserMap-\"++p.nombre})\n});\n\nlet ( <@> ) = parserMap\n\nlet parserReturn = memo((valor:string) => {\n    let innerFn = (cadena, k) => \n        k(Exito(valor, cadena));\n        memoCPS({fn:Parser(innerFn),nombre:\"parserReturn-\"++valor})\n})\n\nlet miko = parseString(\"carlos\") <|> parseString(\"carlos rojas\")\n\n/* execParser(miko, \"carlos rojas contreras\") |> Js.log */\n\n/* let s1 = parseString(\"a\")\nlet rec s2 = arg => run(\n    parserAnd({fn:Parser(s),nombre:\"parserS\"},s1),\n    arg)\nand s = arg => run(\n    parserOr(s1, {fn:Parser(s2),nombre:\"parserS2\"}),\n    arg\n)\n */    \n\n let rec s = arg => run(\n     parserOr(\n         parseString(\"a\"),\n         parserAnd(\n             {fn:Parser(s),nombre:\"parserS\"},\n             parseString(\"a\"))),\n         arg)\nrun({fn:Parser(s),nombre:\"parserS\"}, \"aaaaaaaaa\", Js.log)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re","version":282}}}
Read message 
{"jsonrpc":"2.0","id":832,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":187,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
➡️ running bsc /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsc.exe -c -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules' -I '/home/carlos/Documentos/pruebas_reason/parser-library/lib/bs/src/node_modules/.lsp' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -I '/home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/ocaml' -bin-annot -bs-no-builtin-ppx-ml -open ParserLibrary -ppx /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsppx.exe -nostdlib -color always -w -30-40+6+7+27+32..39+44+45+101 -bs-re-out -impl /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/.lsp/ParserC-ParserLibrary.ast with pwd /home/carlos/Documentos/pruebas_reason/parser-library
<< Replacing lastDefinitions for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 832, "jsonrpc": "2.0", "result": null}
>> Build system running: /home/carlos/Documentos/pruebas_reason/parser-library/node_modules/bs-platform/lib/bsb.exe -make-world
>>> stdout
[1/2] [34mBuilding[39m [2msrc/ParserC.mlast[22m
[2/2] [34mBuilding[39m [2msrc/ParserC.mlast.d[22m
[1/1] [34mBuilding[39m [2msrc/ParserC-ParserLibrary.cmj[22m
>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/bsconfig.json", "diagnostics": []}}
Running diagnostics for file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":832}}
Read message 
{"jsonrpc":"2.0","id":833,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 833, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":834,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 834, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":835,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00977516174316ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 835, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":836,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":190,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 836, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 190, "character": 8}, "end": {"line": 190, "character": 14}}, "contents": {"kind": "markdown", "value": "```\nparserFn(string)\n```\n\n```\ntype parserFn('a) = \n  | Parser((string, continuation('a)) => unit)\n\n```\n\n```\nParser((string, continuation('a)) => unit)\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":837,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":178,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 837, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":838,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 838, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":839,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 839, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":840,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0228881835938ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 840, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":841,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 841, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":842,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 842, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":843,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":183,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Trying for declared Value 1216 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 843, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 183, "character": 9}, "end": {"line": 183, "character": 10}}, "contents": {"kind": "markdown", "value": "```\n(string, continuation(string)) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":844,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":190,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Trying for declared Value 1022 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 844, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 190, "character": 0}, "end": {"line": 190, "character": 3}}, "contents": {"kind": "markdown", "value": "```\n(\n  parser('a),\n  string,\n  continuation('a)\n) => unit\n```\n\n<root>/ParserC.re"}}}
Read message 
{"jsonrpc":"2.0","id":845,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":184,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 845, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":846,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re"},"position":{"line":185,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Trying for declared Value 1165 in file file:///home/carlos/Documentos/pruebas_reason/parser-library/src/ParserC.re
Sending response {"id": 846, "jsonrpc": "2.0", "result": {"range": {"start": {"line": 185, "character": 9}, "end": {"line": 185, "character": 20}}, "contents": {"kind": "markdown", "value": "```\nstring => parser(string)\n```\n\n<root>/ParserC.re"}}}
