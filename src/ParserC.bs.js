// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function run(parser, cadena, k) {
  return Curry._2(parser[0], cadena, k);
}

function parseChar(caracter) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      if (car1 === caracter) {
        return Curry._1(k, /* Exito */Block.__(0, [
                      caracter,
                      resto
                    ]));
      } else {
        return Curry._1(k, /* Fallo */Block.__(1, [
                      "Esperaba " + (String(caracter) + (" y obtuve " + (String(car1) + ""))),
                      cadena
                    ]));
      }
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parseNotChar(caracter) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      if (car1 !== caracter) {
        return Curry._1(k, /* Exito */Block.__(0, [
                      car1,
                      resto
                    ]));
      } else {
        return Curry._1(k, /* Fallo */Block.__(1, [
                      "No Esperaba " + (String(caracter) + " "),
                      cadena
                    ]));
      }
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserAny(param) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      return Curry._1(k, /* Exito */Block.__(0, [
                    car1,
                    resto
                  ]));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserOr(p1, p2) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p1, cadena, (function (s1) {
                    if (s1.tag) {
                      return run(p2, cadena, k);
                    } else {
                      return Curry._1(k, s1);
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserAnd(p1, p2) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p1, cadena, (function (e1) {
                    if (e1.tag) {
                      return Curry._1(k, e1);
                    } else {
                      var valor1 = e1[0];
                      return run(p2, e1[1], (function (e1) {
                                    if (e1.tag) {
                                      return Curry._1(k, e1);
                                    } else {
                                      return Curry._1(k, /* Exito */Block.__(0, [
                                                    /* tuple */[
                                                      valor1,
                                                      e1[0]
                                                    ],
                                                    e1[1]
                                                  ]));
                                    }
                                  }));
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserMap(fn, p) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p, cadena, (function (e1) {
                    if (e1.tag) {
                      return Curry._1(k, e1);
                    } else {
                      return Curry._1(k, /* Exito */Block.__(0, [
                                    Curry._1(fn, e1[0]),
                                    e1[1]
                                  ]));
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserReturn(valor) {
  var innerFn = function (cadena, k) {
    return Curry._1(k, /* Exito */Block.__(0, [
                  valor,
                  cadena
                ]));
  };
  return /* Parser */[innerFn];
}

function parserApply(fP, xP) {
  return parserMap((function (param) {
                return Curry._1(param[0], param[1]);
              }), parserAnd(fP, xP));
}

function parserChoice(lista) {
  return List.fold_left(parserOr, List.hd(lista), List.tl(lista));
}

function parserAll(lista) {
  var concatResults = function (p1, p2) {
    return parserMap((function (param) {
                  return Pervasives.$at(param[0], param[1]);
                }), parserAnd(p1, p2));
  };
  var lista2 = List.map((function (param) {
          return parserMap((function (p1) {
                        return /* :: */[
                                p1,
                                /* [] */0
                              ];
                      }), param);
        }), lista);
  return List.fold_left(concatResults, List.hd(lista2), List.tl(lista2));
}

function parserAnyOf(cadena) {
  return parserChoice(List.map(parseChar, $$Array.to_list(cadena.split(""))));
}

function parseString(cadena) {
  return parserAll(List.map(parseChar, $$Array.to_list(cadena.split(""))));
}

function lift2(f, xP, yP) {
  return parserApply(parserApply(parserReturn(f), xP), yP);
}

function many(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (param) {
                  if (param.tag) {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  /* [] */0,
                                  cadena
                                ]));
                  } else {
                    var resto1 = param[1];
                    var valor1 = param[0];
                    return run(many(p), resto1, (function (param) {
                                  if (param.tag) {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  /* :: */[
                                                    valor1,
                                                    /* [] */0
                                                  ],
                                                  resto1
                                                ]));
                                  } else {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  List.append(/* :: */[
                                                        valor1,
                                                        /* [] */0
                                                      ], param[0]),
                                                  param[1]
                                                ]));
                                  }
                                }));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function many1(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (f) {
                  if (f.tag) {
                    return Curry._1(k, f);
                  } else {
                    var resto1 = f[1];
                    var valor1 = f[0];
                    return run(many(p), resto1, (function (param) {
                                  if (param.tag) {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  /* :: */[
                                                    valor1,
                                                    /* [] */0
                                                  ],
                                                  resto1
                                                ]));
                                  } else {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  List.append(/* :: */[
                                                        valor1,
                                                        /* [] */0
                                                      ], param[0]),
                                                  param[1]
                                                ]));
                                  }
                                }));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function optional(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (param) {
                  if (param.tag) {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  undefined,
                                  cadena
                                ]));
                  } else {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  Caml_option.some(param[0]),
                                  param[1]
                                ]));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function skip(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (f) {
                  if (f.tag) {
                    return Curry._1(k, f);
                  } else {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  /* () */0,
                                  f[1]
                                ]));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function keepLeft(p1, p2) {
  return parserMap((function (param) {
                return param[0];
              }), parserAnd(p1, p2));
}

function keepRight(p1, p2) {
  return parserMap((function (param) {
                return param[1];
              }), parserAnd(p1, p2));
}

var digit = parserAnyOf("0123456789");

var digits = many1(digit);

var intP = parserMap((function (param) {
        return Caml_format.caml_int_of_string($$Array.of_list(param).join(""));
      }), digits);

var whitespace = parserAnyOf(" \t\n\r");

var whitespaces = many(whitespace);

var $neg$pipe = compose;

var $less$pipe$great = parserOr;

var $great$neg$great = parserAnd;

var $less$at$great = parserMap;

var $less$star$great = parserApply;

var $neg$less$less = keepLeft;

var $neg$great$great = keepRight;

exports.compose = compose;
exports.$neg$pipe = $neg$pipe;
exports.run = run;
exports.parseChar = parseChar;
exports.parseNotChar = parseNotChar;
exports.parserAny = parserAny;
exports.parserOr = parserOr;
exports.$less$pipe$great = $less$pipe$great;
exports.parserAnd = parserAnd;
exports.$great$neg$great = $great$neg$great;
exports.parserMap = parserMap;
exports.$less$at$great = $less$at$great;
exports.parserReturn = parserReturn;
exports.parserApply = parserApply;
exports.$less$star$great = $less$star$great;
exports.parserChoice = parserChoice;
exports.parserAll = parserAll;
exports.parserAnyOf = parserAnyOf;
exports.parseString = parseString;
exports.lift2 = lift2;
exports.many = many;
exports.many1 = many1;
exports.optional = optional;
exports.skip = skip;
exports.keepLeft = keepLeft;
exports.keepRight = keepRight;
exports.$neg$less$less = $neg$less$less;
exports.$neg$great$great = $neg$great$great;
exports.digit = digit;
exports.digits = digits;
exports.intP = intP;
exports.whitespace = whitespace;
exports.whitespaces = whitespaces;
/* digit Not a pure module */
