// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function run(parser, cadena, k) {
  return Curry._2(parser[0], cadena, k);
}

function execParser(parser, cadena) {
  var resultados = /* record */[/* contents : [] */0];
  run(parser, cadena, (function (param) {
          if (param.tag || param[1] !== "") {
            return /* () */0;
          } else {
            resultados[0] = /* :: */[
              param[0],
              resultados[0]
            ];
            return /* () */0;
          }
        }));
  return $$Array.of_list(resultados[0]);
}

function memo(fn) {
  var tabla = Hashtbl.create(undefined, 10);
  return (function (arg) {
      try {
        return Hashtbl.find(tabla, arg);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var valor = Curry._1(fn, arg);
          Hashtbl.add(tabla, arg, valor);
          return valor;
        } else {
          throw exn;
        }
      }
    });
}

function memo2(fn) {
  var tabla = Hashtbl.create(undefined, 10);
  return (function (arg1, arg2) {
      try {
        return Hashtbl.find(tabla, /* tuple */[
                    arg1,
                    arg2
                  ]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var valor = Curry._2(fn, arg1, arg2);
          Hashtbl.add(tabla, /* tuple */[
                arg1,
                arg2
              ], valor);
          return valor;
        } else {
          throw exn;
        }
      }
    });
}

function memoCPS(fn) {
  var tablaContinuaciones = Hashtbl.create(undefined, 10);
  var tablaResultados = Hashtbl.create(undefined, 10);
  return /* Parser */[(function (arg, k) {
              var listadoContinuaciones;
              try {
                listadoContinuaciones = Hashtbl.find(tablaContinuaciones, arg);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  listadoContinuaciones = /* [] */0;
                } else {
                  throw exn;
                }
              }
              if (List.length(listadoContinuaciones) === 0) {
                Hashtbl.add(tablaContinuaciones, arg, /* :: */[
                      k,
                      /* [] */0
                    ]);
                return run(fn, arg, (function (result) {
                              try {
                                Hashtbl.find(tablaResultados, arg);
                                return /* () */0;
                              }
                              catch (exn){
                                if (exn === Caml_builtin_exceptions.not_found) {
                                  Hashtbl.add(tablaResultados, arg, result);
                                  var exit = 0;
                                  var lista;
                                  try {
                                    lista = Hashtbl.find(tablaContinuaciones, arg);
                                    exit = 1;
                                  }
                                  catch (exn$1){
                                    if (exn$1 === Caml_builtin_exceptions.not_found) {
                                      return /* () */0;
                                    } else {
                                      throw exn$1;
                                    }
                                  }
                                  if (exit === 1) {
                                    return List.iter((function (cont) {
                                                  return Curry._1(cont, result);
                                                }), lista);
                                  }
                                  
                                } else {
                                  throw exn;
                                }
                              }
                            }));
              } else {
                Hashtbl.replace(tablaContinuaciones, arg, /* :: */[
                      k,
                      listadoContinuaciones
                    ]);
                var exit = 0;
                var valor;
                try {
                  valor = Hashtbl.find(tablaResultados, arg);
                  exit = 1;
                }
                catch (exn$1){
                  if (exn$1 === Caml_builtin_exceptions.not_found) {
                    return /* () */0;
                  } else {
                    throw exn$1;
                  }
                }
                if (exit === 1) {
                  return Curry._1(k, valor);
                }
                
              }
            })];
}

function pushContinuation(tramp, parser, cadena, cont) {
  var exit = 0;
  var val;
  try {
    val = Hashtbl.find(tramp[/* tabla */0], /* tuple */[
          parser,
          cadena
        ]);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      Hashtbl.replace(tramp[/* tabla */0], /* tuple */[
            parser,
            cadena
          ], /* tuple */[
            /* [] */0,
            /* :: */[
              cont,
              /* [] */0
            ]
          ]);
      tramp[/* pila */1] = /* :: */[
        /* tuple */[
          parser,
          cadena,
          (function (result) {
              var match = Hashtbl.find(tramp[/* tabla */0], /* tuple */[
                    parser,
                    cadena
                  ]);
              var continuaciones = match[1];
              var resultados = match[0];
              if (List.mem(result, resultados)) {
                return 0;
              } else {
                Hashtbl.replace(tramp[/* tabla */0], /* tuple */[
                      parser,
                      cadena
                    ], /* tuple */[
                      /* :: */[
                        result,
                        resultados
                      ],
                      continuaciones
                    ]);
                return List.iter((function (c) {
                              return Curry._1(c, result);
                            }), continuaciones);
              }
            })
        ],
        tramp[/* pila */1]
      ];
      return /* () */0;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    var resultados = val[0];
    Hashtbl.replace(tramp[/* tabla */0], /* tuple */[
          parser,
          cadena
        ], /* tuple */[
          resultados,
          /* :: */[
            cont,
            val[1]
          ]
        ]);
    return List.iter(cont, resultados);
  }
  
}

var parseString = memo((function (patron) {
        var innerFn = function (cadena, k) {
          console.log("funcion parseString: " + (patron + (" " + cadena)));
          var longPatron = patron.length;
          var longCadena = cadena.length;
          if (longPatron > longCadena) {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          } else {
            var subcadena = $$String.sub(cadena, 0, longPatron);
            if (subcadena === patron) {
              return Curry._1(k, /* Exito */Block.__(0, [
                            subcadena,
                            $$String.sub(cadena, longPatron, longCadena - longPatron | 0)
                          ]));
            } else {
              return Curry._1(k, /* Fallo */Block.__(1, [
                            "No esperado",
                            cadena
                          ]));
            }
          }
        };
        return memoCPS(/* Parser */[innerFn]);
      }));

var parseChar = memo((function (caracter) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            var car1 = $$String.sub(cadena, 0, 1);
            var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
            if (car1 === caracter) {
              return Curry._1(k, /* Exito */Block.__(0, [
                            caracter,
                            resto
                          ]));
            } else {
              return Curry._1(k, /* Fallo */Block.__(1, [
                            "Esperaba " + (String(caracter) + (" y obtuve " + (String(car1) + ""))),
                            cadena
                          ]));
            }
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* Parser */[innerFn]);
      }));

function parseNotChar(caracter) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      if (car1 !== caracter) {
        return Curry._1(k, /* Exito */Block.__(0, [
                      car1,
                      resto
                    ]));
      } else {
        return Curry._1(k, /* Fallo */Block.__(1, [
                      "No Esperaba " + (String(caracter) + " "),
                      cadena
                    ]));
      }
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserAny(param) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      return Curry._1(k, /* Exito */Block.__(0, [
                    car1,
                    resto
                  ]));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

var parserOr = memo2((function (p1, p2) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            run(p1, cadena, k);
            return run(p2, cadena, k);
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* Parser */[innerFn]);
      }));

var parserAnd = memo2((function (p1, p2) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            return run(p1, cadena, (function (e1) {
                          if (e1.tag) {
                            return Curry._1(k, e1);
                          } else {
                            var valor1 = e1[0];
                            return run(p2, e1[1], (function (e1) {
                                          if (e1.tag) {
                                            return Curry._1(k, e1);
                                          } else {
                                            return Curry._1(k, /* Exito */Block.__(0, [
                                                          /* tuple */[
                                                            valor1,
                                                            e1[0]
                                                          ],
                                                          e1[1]
                                                        ]));
                                          }
                                        }));
                          }
                        }));
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* Parser */[innerFn]);
      }));

var parserMap = memo((function (fn, p) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            return run(p, cadena, (function (e1) {
                          if (e1.tag) {
                            return Curry._1(k, e1);
                          } else {
                            return Curry._1(k, /* Exito */Block.__(0, [
                                          Curry._1(fn, e1[0]),
                                          e1[1]
                                        ]));
                          }
                        }));
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* Parser */[innerFn]);
      }));

var miko = parserOr(parseString("carlos"), parseString("carlos rojas"));

console.log(execParser(parseString("carlos rojas"), "carlos rojas"));

run(miko, "carlos rojas c", (function (prim) {
        console.log(prim);
        return /* () */0;
      }));

run(miko, "carlos rojas c", (function (prim) {
        console.log(prim);
        return /* () */0;
      }));

run(miko, "carlos rojas c", (function (prim) {
        console.log(prim);
        return /* () */0;
      }));

var $neg$pipe = compose;

var $less$pipe$great = parserOr;

var $great$neg$great = parserAnd;

var $less$at$great = parserMap;

exports.compose = compose;
exports.$neg$pipe = $neg$pipe;
exports.run = run;
exports.execParser = execParser;
exports.memo = memo;
exports.memo2 = memo2;
exports.memoCPS = memoCPS;
exports.pushContinuation = pushContinuation;
exports.parseString = parseString;
exports.parseChar = parseChar;
exports.parseNotChar = parseNotChar;
exports.parserAny = parserAny;
exports.parserOr = parserOr;
exports.$less$pipe$great = $less$pipe$great;
exports.parserAnd = parserAnd;
exports.$great$neg$great = $great$neg$great;
exports.parserMap = parserMap;
exports.$less$at$great = $less$at$great;
exports.miko = miko;
/* parseString Not a pure module */
