// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function run(parser, cadena, k) {
  return Curry._2(parser[0], cadena, k);
}

function parseChar(caracter) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      if (car1 === caracter) {
        return Curry._1(k, /* Exito */Block.__(0, [
                      caracter,
                      resto
                    ]));
      } else {
        return Curry._1(k, /* Fallo */Block.__(1, [
                      "Esperaba " + (String(caracter) + (" y obtuve " + (String(car1) + ""))),
                      cadena
                    ]));
      }
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parseNotChar(caracter) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      if (car1 !== caracter) {
        return Curry._1(k, /* Exito */Block.__(0, [
                      car1,
                      resto
                    ]));
      } else {
        return Curry._1(k, /* Fallo */Block.__(1, [
                      "No Esperaba " + (String(caracter) + " "),
                      cadena
                    ]));
      }
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserAny(param) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      var car1 = $$String.sub(cadena, 0, 1);
      var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
      return Curry._1(k, /* Exito */Block.__(0, [
                    car1,
                    resto
                  ]));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserOr(p1, p2) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p1, cadena, (function (s1) {
                    if (s1.tag) {
                      return run(p2, cadena, k);
                    } else {
                      return Curry._1(k, s1);
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserAnd(p1, p2) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p1, cadena, (function (e1) {
                    if (e1.tag) {
                      return Curry._1(k, e1);
                    } else {
                      var valor1 = e1[0];
                      return run(p2, e1[1], (function (e1) {
                                    if (e1.tag) {
                                      return Curry._1(k, e1);
                                    } else {
                                      return Curry._1(k, /* Exito */Block.__(0, [
                                                    /* tuple */[
                                                      valor1,
                                                      e1[0]
                                                    ],
                                                    e1[1]
                                                  ]));
                                    }
                                  }));
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserMap(fn, p) {
  var innerFn = function (cadena, k) {
    var match = cadena.length;
    if (match !== 0) {
      return run(p, cadena, (function (e1) {
                    if (e1.tag) {
                      return Curry._1(k, e1);
                    } else {
                      return Curry._1(k, /* Exito */Block.__(0, [
                                    Curry._1(fn, e1[0]),
                                    e1[1]
                                  ]));
                    }
                  }));
    } else {
      return Curry._1(k, /* Fallo */Block.__(1, [
                    "Final de la cadena",
                    cadena
                  ]));
    }
  };
  return /* Parser */[innerFn];
}

function parserReturn(valor) {
  var innerFn = function (cadena, k) {
    return Curry._1(k, /* Exito */Block.__(0, [
                  valor,
                  cadena
                ]));
  };
  return /* Parser */[innerFn];
}

function parserApply(fP, xP) {
  return parserMap((function (param) {
                return Curry._1(param[0], param[1]);
              }), parserAnd(fP, xP));
}

function parserChoice(lista) {
  return List.fold_left(parserOr, List.hd(lista), List.tl(lista));
}

function parserAll(lista) {
  var concatResults = function (p1, p2) {
    return parserMap((function (param) {
                  return Pervasives.$at(param[0], param[1]);
                }), parserAnd(p1, p2));
  };
  var lista2 = List.map((function (param) {
          return parserMap((function (p1) {
                        return /* :: */[
                                p1,
                                /* [] */0
                              ];
                      }), param);
        }), lista);
  return List.fold_left(concatResults, List.hd(lista2), List.tl(lista2));
}

function parserAnyOf(cadena) {
  return parserChoice(List.map(parseChar, $$Array.to_list(cadena.split(""))));
}

function parseString(cadena) {
  return parserAll(List.map(parseChar, $$Array.to_list(cadena.split(""))));
}

function lift2(f, xP, yP) {
  return parserApply(parserApply(parserReturn(f), xP), yP);
}

function many(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (param) {
                  if (param.tag) {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  /* [] */0,
                                  cadena
                                ]));
                  } else {
                    var resto1 = param[1];
                    var valor1 = param[0];
                    return run(many(p), resto1, (function (param) {
                                  if (param.tag) {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  /* :: */[
                                                    valor1,
                                                    /* [] */0
                                                  ],
                                                  resto1
                                                ]));
                                  } else {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  List.append(/* :: */[
                                                        valor1,
                                                        /* [] */0
                                                      ], param[0]),
                                                  param[1]
                                                ]));
                                  }
                                }));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function many1(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (f) {
                  if (f.tag) {
                    return Curry._1(k, f);
                  } else {
                    var resto1 = f[1];
                    var valor1 = f[0];
                    return run(many(p), resto1, (function (param) {
                                  if (param.tag) {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  /* :: */[
                                                    valor1,
                                                    /* [] */0
                                                  ],
                                                  resto1
                                                ]));
                                  } else {
                                    return Curry._1(k, /* Exito */Block.__(0, [
                                                  List.append(/* :: */[
                                                        valor1,
                                                        /* [] */0
                                                      ], param[0]),
                                                  param[1]
                                                ]));
                                  }
                                }));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function optional(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (param) {
                  if (param.tag) {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  undefined,
                                  cadena
                                ]));
                  } else {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  Caml_option.some(param[0]),
                                  param[1]
                                ]));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function skip(p) {
  var innerFn = function (cadena, k) {
    return run(p, cadena, (function (f) {
                  if (f.tag) {
                    return Curry._1(k, f);
                  } else {
                    return Curry._1(k, /* Exito */Block.__(0, [
                                  /* () */0,
                                  f[1]
                                ]));
                  }
                }));
  };
  return /* Parser */[innerFn];
}

function keepLeft(p1, p2) {
  return parserMap((function (param) {
                return param[0];
              }), parserAnd(p1, p2));
}

function keepRight(p1, p2) {
  return parserMap((function (param) {
                return param[1];
              }), parserAnd(p1, p2));
}

var digit = parserAnyOf("0123456789");

var digits = many1(digit);

var intP = parserMap((function (param) {
        return Caml_format.caml_int_of_string($$Array.of_list(param).join(""));
      }), digits);

var whitespace = parserAnyOf(" \t\n\r");

var whitespaces = many(whitespace);

var ParserC = /* module */[
  /* compose */compose,
  /* -| */compose,
  /* run */run,
  /* parseChar */parseChar,
  /* parseNotChar */parseNotChar,
  /* parserAny */parserAny,
  /* parserOr */parserOr,
  /* <|> */parserOr,
  /* parserAnd */parserAnd,
  /* >-> */parserAnd,
  /* parserMap */parserMap,
  /* <@> */parserMap,
  /* parserReturn */parserReturn,
  /* parserApply */parserApply,
  /* <*> */parserApply,
  /* parserChoice */parserChoice,
  /* parserAll */parserAll,
  /* parserAnyOf */parserAnyOf,
  /* parseString */parseString,
  /* lift2 */lift2,
  /* many */many,
  /* many1 */many1,
  /* optional */optional,
  /* skip */skip,
  /* keepLeft */keepLeft,
  /* keepRight */keepRight,
  /* -<< */keepLeft,
  /* ->> */keepRight,
  /* digit */digit,
  /* digits */digits,
  /* intP */intP,
  /* whitespace */whitespace,
  /* whitespaces */whitespaces
];

function mcd(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    var r = Caml_int32.mod_(a, b);
    if (r !== 0) {
      _b = r;
      _a = b;
      continue ;
    } else {
      return b;
    }
  };
}

function mcm(a, b) {
  return Caml_int32.div(Caml_int32.imul(a, b), mcd(a, b));
}

function crearFraccion(numerador, denominador) {
  return /* record */[
          /* numerador */Caml_int32.div(numerador, mcd(numerador, denominador)),
          /* denominador */Caml_int32.div(denominador, mcd(numerador, denominador))
        ];
}

function $plus$slash(f1, f2) {
  var denominador = mcm(f1[/* denominador */1], f2[/* denominador */1]);
  var num1 = Caml_int32.div(Caml_int32.imul(f1[/* numerador */0], denominador), f1[/* denominador */1]);
  var num2 = Caml_int32.div(Caml_int32.imul(f2[/* numerador */0], denominador), f2[/* denominador */1]);
  var numerador = num1 + num2 | 0;
  return crearFraccion(numerador, denominador);
}

function $neg$slash(f1, f2) {
  var denominador = mcm(f1[/* denominador */1], f2[/* denominador */1]);
  var num1 = Caml_int32.div(Caml_int32.imul(f1[/* numerador */0], denominador), f1[/* denominador */1]);
  var num2 = Caml_int32.div(Caml_int32.imul(f2[/* numerador */0], denominador), f2[/* denominador */1]);
  var numerador = num1 - num2 | 0;
  return crearFraccion(numerador, denominador);
}

function $star$slash(f1, f2) {
  var numerador = Caml_int32.imul(f1[/* numerador */0], f2[/* numerador */0]);
  var denominador = Caml_int32.imul(f1[/* denominador */1], f2[/* denominador */1]);
  return crearFraccion(numerador, denominador);
}

function $slash$slash(f1, f2) {
  var numerador = Caml_int32.imul(f1[/* numerador */0], f2[/* denominador */1]);
  var denominador = Caml_int32.imul(f1[/* denominador */1], f2[/* numerador */0]);
  return crearFraccion(numerador, denominador);
}

function string_of_frac(f) {
  return String(f[/* numerador */0]) + ("/" + String(f[/* denominador */1]));
}

var operador = parserMap((function (param) {
        switch (param) {
          case "*" : 
              return /* Times */2;
          case "+" : 
              return /* Plus */0;
          case "-" : 
              return /* Minus */1;
          default:
            return /* DividedBy */3;
        }
      }), keepLeft(keepRight(whitespaces, parserAnyOf("/*-+")), whitespaces));

var parseFrac = parserMap((function (param) {
        return crearFraccion(param[0], param[1]);
      }), parserAnd(keepLeft(intP, parseChar("/")), intP));

var operaFrac = parserMap((function (param) {
        var f2 = param[1];
        var match = param[0];
        var f1 = match[0];
        switch (match[1]) {
          case 0 : 
              return $plus$slash(f1, f2);
          case 1 : 
              return $neg$slash(f1, f2);
          case 2 : 
              return $star$slash(f1, f2);
          case 3 : 
              return $slash$slash(f1, f2);
          
        }
      }), parserAnd(parserAnd(parseFrac, operador), parseFrac));

run(parserMap(string_of_frac, operaFrac), "8/5+2/4", (function (param) {
        console.log(param[0]);
        return /* () */0;
      }));

exports.ParserC = ParserC;
exports.mcd = mcd;
exports.mcm = mcm;
exports.crearFraccion = crearFraccion;
exports.$plus$slash = $plus$slash;
exports.$neg$slash = $neg$slash;
exports.$star$slash = $star$slash;
exports.$slash$slash = $slash$slash;
exports.string_of_frac = string_of_frac;
exports.operador = operador;
exports.parseFrac = parseFrac;
exports.operaFrac = operaFrac;
/* digit Not a pure module */
