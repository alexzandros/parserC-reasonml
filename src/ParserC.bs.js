// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function run(parser, cadena, k) {
  var match = parser[/* fn */0];
  return Curry._2(match[0], cadena, k);
}

function execParser(parser, cadena) {
  var resultados = /* record */[/* contents : [] */0];
  run(parser, cadena, (function (param) {
          if (param.tag) {
            return /* () */0;
          } else {
            resultados[0] = /* :: */[
              param[0],
              resultados[0]
            ];
            return /* () */0;
          }
        }));
  return $$Array.of_list(resultados[0]);
}

function memo(fn) {
  var tabla = Hashtbl.create(undefined, 10);
  return (function (arg) {
      try {
        return Hashtbl.find(tabla, arg);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var valor = Curry._1(fn, arg);
          Hashtbl.add(tabla, arg, valor);
          return valor;
        } else {
          throw exn;
        }
      }
    });
}

function memoCPS(fn) {
  var isResultSaved = function (tabla, cadena, result) {
    return List.mem(result, Hashtbl.find_all(tabla, cadena));
  };
  var tablaContinuaciones = Hashtbl.create(undefined, 10);
  var tablaResultados = Hashtbl.create(undefined, 10);
  var innerFn = /* Parser */[(function (arg, k) {
        var listadoContinuaciones = Hashtbl.find_all(tablaContinuaciones, arg);
        if (List.length(listadoContinuaciones) === 0) {
          Hashtbl.add(tablaContinuaciones, arg, k);
          return run(fn, arg, (function (result) {
                        var match = isResultSaved(tablaResultados, arg, result);
                        if (match) {
                          return /* () */0;
                        } else {
                          Hashtbl.add(tablaResultados, arg, result);
                          var lista = Hashtbl.find_all(tablaContinuaciones, arg);
                          return List.iter((function (cont) {
                                        return Curry._1(cont, result);
                                      }), lista);
                        }
                      }));
        } else {
          Hashtbl.add(tablaContinuaciones, arg, k);
          return List.iter(Curry.__1(k), Hashtbl.find_all(tablaResultados, arg));
        }
      })];
  return /* record */[
          /* fn */innerFn,
          /* nombre */fn[/* nombre */1]
        ];
}

var parseString = memo((function (patron) {
        var innerFn = function (cadena, k) {
          var longPatron = patron.length;
          var longCadena = cadena.length;
          if (longPatron > longCadena) {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          } else {
            var subcadena = $$String.sub(cadena, 0, longPatron);
            if (subcadena === patron) {
              return Curry._1(k, /* Exito */Block.__(0, [
                            subcadena,
                            $$String.sub(cadena, longPatron, longCadena - longPatron | 0)
                          ]));
            } else {
              return Curry._1(k, /* Fallo */Block.__(1, [
                            "No esperado",
                            cadena
                          ]));
            }
          }
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parseString-" + patron
                  ]);
      }));

var parseChar = memo((function (caracter) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            var car1 = $$String.sub(cadena, 0, 1);
            var resto = $$String.sub(cadena, 1, cadena.length - 1 | 0);
            if (car1 === caracter) {
              return Curry._1(k, /* Exito */Block.__(0, [
                            caracter,
                            resto
                          ]));
            } else {
              return Curry._1(k, /* Fallo */Block.__(1, [
                            "Esperaba " + (String(caracter) + (" y obtuve " + (String(car1) + ""))),
                            cadena
                          ]));
            }
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parseChar-" + caracter
                  ]);
      }));

var parserOr = memo((function (p1, p2) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            run(p1, cadena, k);
            run(p2, cadena, k);
            return /* () */0;
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parserOr-" + (p1[/* nombre */1] + ("-" + p2[/* nombre */1]))
                  ]);
      }));

var parserAnd = memo((function (p1, p2) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            return run(p1, cadena, (function (e1) {
                          if (e1.tag) {
                            return Curry._1(k, e1);
                          } else {
                            var valor1 = e1[0];
                            return run(p2, e1[1], (function (e1) {
                                          if (e1.tag) {
                                            return Curry._1(k, e1);
                                          } else {
                                            return Curry._1(k, /* Exito */Block.__(0, [
                                                          valor1 + e1[0],
                                                          e1[1]
                                                        ]));
                                          }
                                        }));
                          }
                        }));
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parserAnd-" + (p1[/* nombre */1] + ("-" + p2[/* nombre */1]))
                  ]);
      }));

var parserMap = memo((function (fn, p) {
        var innerFn = function (cadena, k) {
          var match = cadena.length;
          if (match !== 0) {
            return run(p, cadena, (function (e1) {
                          if (e1.tag) {
                            return Curry._1(k, e1);
                          } else {
                            return Curry._1(k, /* Exito */Block.__(0, [
                                          Curry._1(fn, e1[0]),
                                          e1[1]
                                        ]));
                          }
                        }));
          } else {
            return Curry._1(k, /* Fallo */Block.__(1, [
                          "Final de la cadena",
                          cadena
                        ]));
          }
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parserMap-" + p[/* nombre */1]
                  ]);
      }));

var parserReturn = memo((function (valor) {
        var innerFn = function (cadena, k) {
          return Curry._1(k, /* Exito */Block.__(0, [
                        valor,
                        cadena
                      ]));
        };
        return memoCPS(/* record */[
                    /* fn : Parser */[innerFn],
                    /* nombre */"parserReturn-" + valor
                  ]);
      }));

var miko = Curry._1(parserOr(parseString("carlos")), parseString("carlos rojas"));

function s(arg) {
  var partial_arg = Curry._1(parserOr(parseString("a")), Curry._1(parserAnd(/* record */[
                /* fn : Parser */[s],
                /* nombre */"parserS"
              ]), parseString("a")));
  return (function (param) {
      return run(partial_arg, arg, param);
    });
}

run(/* record */[
      /* fn : Parser */[s],
      /* nombre */"parserS"
    ], "aaaaaaaaa", (function (prim) {
        console.log(prim);
        return /* () */0;
      }));

var $neg$pipe = compose;

var $less$pipe$great = parserOr;

var $great$neg$great = parserAnd;

var $less$at$great = parserMap;

exports.compose = compose;
exports.$neg$pipe = $neg$pipe;
exports.run = run;
exports.execParser = execParser;
exports.memo = memo;
exports.memoCPS = memoCPS;
exports.parseString = parseString;
exports.parseChar = parseChar;
exports.parserOr = parserOr;
exports.$less$pipe$great = $less$pipe$great;
exports.parserAnd = parserAnd;
exports.$great$neg$great = $great$neg$great;
exports.parserMap = parserMap;
exports.$less$at$great = $less$at$great;
exports.parserReturn = parserReturn;
exports.miko = miko;
exports.s = s;
/* parseString Not a pure module */
